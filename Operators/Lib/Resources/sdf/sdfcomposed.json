[
  {
    "Author": "gaziya5 aka gaz",
    "OriginalCode": "#define sabs(a) sqrt(a * a + 0.005)\n  #define smin(a,b) SMin1(a,b,0.0003)\n  #define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n  float SMin1(float a, float b, float k){\n    return a + 0.5 * ((b-a) - sqrt((b-a) * (b-a) + k));\n  }\n  vec2 fold(vec2 p, int n){\n    p.x=sabs(p.x);\n    vec2 v=vec2(0,1);\n    for(int i=0;i < n;i++){\n      p-=2.0*smin(0.0,dot(p,v))*v;\n      v=normalize(vec2(v.x-1.0,v.y));\n    }\n    return p;\n  }\n  float sdTorus( vec3 p, vec2 t ){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n  }\n  float de(vec3 p){\n    float A=5.566;\n    float c=7.0;\n    p=mod(p,c)-c*0.5;\n    p.xz=fold(p.xz,5);\n    for(int i=0;i<5;i++){\n      p.xy=abs(p.xy)-2.0;\n      p.yz=abs(p.yz)-2.5;\n      p.xy*=rot(A);\n      p.yz*=rot(A*0.5);\n      p=abs(p)-2.0;\n    }\n    vec2 s=vec2(0.05,0.02);\n    float h=0.08;\n    float de=1.0;\n    vec3 q=p;\n    q.xy=fold(q.xy,5);\n    q.y-=2.;\n    q.x-=clamp(q.x,-h,h);\n    de=min(de,sdTorus(q,s));\n    q=p;\n    q.xy*=rot(M_PI/exp2(5.0));\n    q.xy=fold(q.xy,5);\n    q.y-=2.0;\n    q.x-=clamp(q.x,-h,h);\n    de=min(de,sdTorus(q.xzy,s));\n    return de;\n  }",
    "ConvertedCode": "// author: gaziya5 aka gaz\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 5.566\n// B: 7.0\n// C: N/A\n// Offset: N/A\n\nfloat SMin1(float a, float b, float k){\n    return a + 0.5 * ((b-a) - sqrt((b-a) * (b-a) + k));\n}\nfloat2 fold(float2 p, int n){\n    p.x=sqrt(p.x * p.x + 0.005);\n    float2 v=float2(0,1);\n    for(int i=0;i < n;i++){\n      p-=2.0*SMin1(0.0,dot(p,v),0.0003)*v;\n      v=normalize(float2(v.x-1.0,v.y));\n    }\n    return p;\n}\nfloat sdTorus( float3 p, float2 t ){\n    float2 q = float2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n    float _A=A;\n    float c=B;\n    float3 p_iter = p;\n    p_iter=fmod(p_iter,c)-c*0.5;\n    p_iter.xz=fold(p_iter.xz,5);\n    for(int i=0;i<5;i++){\n      p_iter.xy=abs(p_iter.xy)-2.0;\n      p_iter.yz=abs(p_iter.yz)-2.5;\n      p_iter.xy=mul(p_iter.xy, float2x2(cos(_A),sin(_A),-sin(_A),cos(_A)));\n      p_iter.yz=mul(p_iter.yz, float2x2(cos(_A*0.5),sin(_A*0.5),-sin(_A*0.5),cos(_A*0.5)));\n      p_iter=abs(p_iter)-2.0;\n    }\n    float2 s=float2(0.05,0.02);\n    float h=0.08;\n    float de=1.0;\n    float3 q=p_iter;\n    q.xy=fold(q.xy,5);\n    q.y-=2.0;\n    q.x-=clamp(q.x,-h,h);\n    de=min(de,sdTorus(q,s));\n    q=p_iter;\n    q.xy=mul(q.xy, float2x2(cos(3.14159265/exp2(5.0)),sin(3.14159265/exp2(5.0)),-sin(3.14159265/exp2(5.0)),cos(3.14159265/exp2(5.0))));\n    q.xy=fold(q.xy,5);\n    q.y-=2.0;\n    q.x-=clamp(q.x,-h,h);\n    de=min(de,sdTorus(q.xzy,s));\n    return de;",
    "A": 5.566,
    "B": 7.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "gaziya5 aka gaz",
    "OriginalCode": "vec4 sphere (vec4 z) {\n    float r2 = dot (z.xyz, z.xyz);\n    if (r2 < 2.0)\n      z *= (1.0 / r2);\n    else z *= 0.5;\n    return z;\n  }\n  vec3 box (vec3 z) {\n    return clamp (z, -1.0, 1.0) * 2.0 - z;\n  }\n  float DE0 (vec3 pos) {\n    vec3 from = vec3 (0.0);\n    vec3 z = pos - from;\n    float r = dot (pos - from, pos - from) * pow (length (z), 2.0);\n    return (1.0 - smoothstep (0.0, 0.01, r)) * 0.01;\n  }\n  float DE2 (vec3 pos) {\n    vec3 params = vec3 (0.5, 0.5, 0.5);\n    vec4 scale = vec4 (-20.0 * 0.272321);\n    vec4 p = vec4 (pos, 1.0), p0 = p;\n    vec4 c = vec4 (params, 0.5) - 0.5; // param = 0..1\n\n    for (float i = 0.0; i < 10.0; i++) {\n      p.xyz = box(p.xyz);\n      p = sphere(p);\n      p = p * scale + c;\n    }\n    return length(p.xyz) / p.w;\n  }\n  float de (vec3 pos) {\n    return max (DE0(pos), DE2(pos));\n  }",
    "ConvertedCode": "// author: gaziya5 aka gaz\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat4 sphere (float4 z) {\n    float r2 = dot (z.xyz, z.xyz);\n    if (r2 < 2.0)\n      z = mul(z, (1.0 / r2));\n    else z = mul(z, 0.5);\n    return z;\n}\nfloat3 box (float3 z) {\n    return clamp (z, -1.0, 1.0) * 2.0 - z;\n}\nfloat DE0 (float3 pos) {\n    float3 from = float3 (0.0);\n    float3 z = pos - from;\n    float r = dot (pos - from, pos - from) * pow (length (z), 2.0);\n    return (1.0 - smoothstep (0.0, 0.01, r)) * 0.01;\n}\nfloat DE2 (float3 pos) {\n    float3 params_val = float3 (0.5, 0.5, 0.5);\n    float4 scale = float4 (-20.0 * 0.272321);\n    float4 p_iter = float4 (pos, 1.0), p0 = p_iter;\n    float4 c = float4 (params_val, 0.5) - 0.5; // param = 0..1\n\n    for (float i = 0.0; i < 10.0; i++) {\n      p_iter.xyz = box(p_iter.xyz);\n      p_iter = sphere(p_iter);\n      p_iter = p_iter * scale + c;\n    }\n    return length(p_iter.xyz) / p_iter.w;\n}\n\n    return max (DE0(p), DE2(p));",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "jorge2017a1",
    "OriginalCode": "float de2(vec3 p) {\n    vec3 op = p;\n    p = abs(1.0 - mod(p, 2.));\n    float r = 0., power = 8., dr = 1.;\n    vec3 z = p;\n    for (int i = 0; i < 7; i++) {\n      op = -1.0 + 2.0 * fract(0.5 * op + 0.5);\n      float r2 = dot(op, op);\n      r = length(z);\n      if (r > 1.616) break;\n      float theta = acos(z.z / r);\n      float phi = atan(z.y, z.x);\n      dr = pow(r, power - 1.) * power * dr + 1.;\n      float zr = pow(r, power);\n      theta = theta * power;\n      phi = phi * power;\n      z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n      z += p;\n    }\n    return (.5 * log(r) * r / dr);\n  }\n\n  float de1(vec3 p) {\n    float s = 1.;\n    float d = 0.;\n    vec3 r,q;\n    r = p;\n    q = r;\n    for (int j = 0; j < 6; j++) {\n      r = abs(mod(q * s + 1.5, 2.) - 1.);\n      r = max(r, r.yzx);\n      d = max(d, (.3 - length(r *0.985) * .3) / s);\n      s *= 2.1;\n    }\n    return d;\n  }\n  float de(vec3 p) {\n    return min(de1(p), de2(p));\n  }",
    "ConvertedCode": "// author: jorge2017a1\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat de2(float3 p) {\n    float3 op = p;\n    p = abs(1.0 - fmod(p, 2.0));\n    float r = 0.0, power = 8.0, dr = 1.0;\n    float3 z = p;\n    for (int i = 0; i < 7; i++) {\n      op = -1.0 + 2.0 * frac(0.5 * op + 0.5);\n      float r2 = dot(op, op);\n      r = length(z);\n      if (r > 1.616) break;\n      float theta = acos(z.z / r);\n      float phi = atan2(z.y, z.x);\n      dr = pow(r, power - 1.0) * power * dr + 1.0;\n      float zr = pow(r, power);\n      theta = theta * power;\n      phi = phi * power;\n      z = zr * float3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n      z += p;\n    }\n    return (0.5 * log(r) * r / dr);\n}\nfloat de1(float3 p) {\n    float s = 1.0;\n    float d = 0.0;\n    float3 r,q;\n    r = p;\n    q = r;\n    for (int j = 0; j < 6; j++) {\n      r = abs(fmod(q * s + 1.5, 2.0) - 1.0);\n      r = max(r, r.yzx);\n      d = max(d, (0.3 - length(r *0.985) * 0.3) / s);\n      s=mul(s, 2.1);\n    }\n    return d;\n}\n\n    return min(de1(p), de2(p));",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "mrange",
    "OriginalCode": "void sphere_fold(inout vec3 z, inout float dz) {\n  const float fixed_radius2 = 1.9;\n  const float min_radius2   = 0.5;\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n      float temp = (fixed_radius2 / min_radius2);\n      z *= temp;\n      dz *= temp;\n    } else if(r2 < fixed_radius2) {\n      float temp = (fixed_radius2 / r2);\n      z *= temp;\n      dz *= temp;\n    }\n  }\n  vec3 pmin(vec3 a, vec3 b, vec3 k) {\n    vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n  }\n  void box_fold(float k, inout vec3 z, inout float dz) {\n    // soft clamp after suggestion from ollij\n    const vec3  folding_limit = vec3(1.0);\n    vec3 zz = sign(z)*pmin(abs(z), folding_limit, vec3(k));\n    z = zz * 2.0 - z;\n  }\n  float sphere(vec3 p, float t) {\n    return length(p)-t;\n  }\n  float torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n  }\n  float de(vec3 z) {\n    const float scale = -2.8;\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    const float k = 0.05;\n    for(int n = 0; n < 5; ++n) {\n      box_fold(k/dr, z, dr);\n      sphere_fold(z, dr);\n      z = scale * z + offset;\n      dr = dr * abs(scale) + 1.0;\n      float r1 = sphere(z, 5.0);\n      float r2 = torus(z, vec2(8.0, 1));\n      float r = n < 4 ? r2 : r1;\n      float dd = r / abs(dr);\n      if (n < 3 || dd < fd) {\n        fd = dd;\n      }\n    }\n    return fd;\n  }",
    "ConvertedCode": "// author: mrange\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: -2.8\n// B: 0.05\n// C: N/A\n// Offset: N/A\nvoid sphere_fold(inout float3 z, inout float dz) {\n  const float fixed_radius2 = 1.9;\n  const float min_radius2   = 0.5;\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n      float temp = (fixed_radius2 / min_radius2);\n      z = mul(z, temp);\n      dz = mul(dz, temp);\n    } else if(r2 < fixed_radius2) {\n      float temp = (fixed_radius2 / r2);\n      z = mul(z, temp);\n      dz = mul(dz, temp);\n    }\n}\nfloat3 pmin(float3 a, float3 b, float3 k) {\n    float3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return lerp(b, a, h) - k*h*(1.0-h);\n}\nvoid box_fold(float k, inout float3 z, inout float dz) {\n    // soft clamp after suggestion from ollij\n    const float3  folding_limit = float3(1.0);\n    float3 zz = sign(z)*pmin(abs(z), folding_limit, float3(k));\n    z = zz * 2.0 - z;\n}\nfloat sphere(float3 p, float t) {\n    return length(p)-t;\n}\nfloat torus(float3 p, float2 t) {\n    float2 q = float2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n    float3 z = p;\n    const float scale = A;\n    float3 local_offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    const float k = B;\n    for(int n = 0; n < 5; ++n) {\n      box_fold(k/dr, z, dr);\n      sphere_fold(z, dr);\n      z = scale * z + local_offset;\n      dr = dr * abs(scale) + 1.0;\n      float r1 = sphere(z, 5.0);\n      float r2 = torus(z, float2(8.0, 1));\n      float r = n < 4 ? r2 : r1;\n      float dd = r / abs(dr);\n      if (n < 3 || dd < fd) {\n        fd = dd;\n      }\n    }\n    return fd;",
    "A": -2.8,
    "B": 0.05,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "evilryu",
    "OriginalCode": "void sphere_fold(inout vec3 z, inout float dz) {\n    float fixed_radius2 = 1.9;\n    float min_radius2 = 0.1;\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n      float temp = (fixed_radius2 / min_radius2);\n      z *= temp; dz *= temp;\n    }else if(r2 < fixed_radius2) {\n      float temp = (fixed_radius2 / r2);\n      z *= temp; dz *= temp;\n    }\n  }\n  void box_fold(inout vec3 z, inout float dz) {\n    float folding_limit = 1.0;\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n  }\n  float de(vec3 z) {\n    vec3 offset = z;\n    float scale = -2.8;\n    float dr = 1.0;\n    for(int n = 0; n < 15; ++n) {\n      box_fold(z, dr);\n      sphere_fold(z, dr);\n      z = scale * z + offset;\n      dr = dr * abs(scale) + 1.0;\n    }\n    float r = length(z);\n    return r / abs(dr);\n  }",
    "ConvertedCode": "// author: evilryu\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: -2.8\n// B: N/A\n// C: N/A\n// Offset: N/A\nvoid sphere_fold(inout float3 z, inout float dz) {\n    float fixed_radius2 = 1.9;\n    float min_radius2 = 0.1;\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n      float temp = (fixed_radius2 / min_radius2);\n      z = mul(z, temp); dz = mul(dz, temp);\n    }else if(r2 < fixed_radius2) {\n      float temp = (fixed_radius2 / r2);\n      z = mul(z, temp); dz = mul(dz, temp);\n    }\n}\nvoid box_fold(inout float3 z, inout float dz) {\n    float folding_limit = 1.0;\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\n    float3 z = p;\n    float3 local_offset = z;\n    float scale = A;\n    float dr = 1.0;\n    for(int n = 0; n < 15; ++n) {\n      box_fold(z, dr);\n      sphere_fold(z, dr);\n      z = scale * z + local_offset;\n      dr = dr * abs(scale) + 1.0;\n    }\n    float r = length(z);\n    return r / abs(dr);",
    "A": -2.8,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "mrange",
    "OriginalCode": "vec3 mod3(inout vec3 p, vec3 size) {\n    vec3 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return c;\n  }\n  void sphere_fold(float fr, inout vec3 z, inout float dz) {\n  const float fixed_radius2 = 4.5;\n  const float min_radius2   = 0.5;\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n      float temp = (fr / min_radius2);\n      z *= temp;\n      dz *= temp;\n    } else if(r2 < fr) {\n      float temp = (fr / r2);\n      z *= temp;\n      dz *= temp;\n    }\n  }\n  void box_fold(float fl, inout vec3 z, inout float dz) {\n    z = clamp(z, -fl, fl) * 2.0 - z;\n  }\n  float sphere(vec3 p, float t) {\n    return length(p)-t;\n  }\n  float torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n  }\n  float mb(float fl, float fr, vec3 z) {\n    vec3 offset = z;\n    const float scale = -3.0;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n      box_fold65(fl, z, dr);\n      sphere_fold65(fr, z, dr);\n      z = scale * z + offset;\n      dr = dr * abs(scale) + 1.0;\n      float r1 = sphere65(z, 5.0);\n      float r2 = torus65(z, vec2(8.0, 1));\n      float r = n < 4 ? r2 : r1;\n      float dd = r / abs(dr);\n      if (n < 3 || dd < fd) {\n        fd = dd;\n      }\n    }\n    return fd;\n  }\n  #define PATHA 0.4*vec2(0.11, 0.21)\n  #define PATHB 0.7*vec2(13.0, 3.0)\n  float de(vec3 p) {\n    float tm = p.z;\n    const float folding_limit = 2.3;\n    const vec3  rep = vec3(10.0);\n\n    vec3 wrap = vec3(sin(tm*PATHA)*PATHB, tm);\n    vec3 wrapDeriv = normalize(vec3(PATHA*PATHB*cos(PATHA*tm), 1.0));\n    p.xy -= wrap.xy;\n    p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n    p -= rep*vec3(0.5, 0.0, 0.0);\n    p.y *= (1.0 + 0.1*abs(p.y));\n    vec3 i = mod3(p, rep);\n\n    const float fixed_radius2 = 4.5;\n    float fl = folding_limit + 0.3*sin(0.025*p.z+1.0)- 0.3;\n    float fr = fixed_radius2 - 3.0*cos(0.025*sqrt(0.5)*p.z-1.0);\n\n    return mb(fl, fr, p);\n  }",
    "ConvertedCode": "// author: mrange\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat3 mod3(inout float3 p, float3 size) {\n    float3 c = floor((p + size*0.5)/size);\n    p = fmod(p + size*0.5, size) - size*0.5;\n    return c;\n}\nvoid sphere_fold(float fr, inout float3 z, inout float dz) {\n  const float fixed_radius2 = 4.5;\n  const float min_radius2   = 0.5;\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n      float temp = (fr / min_radius2);\n      z = mul(z, temp);\n      dz = mul(dz, temp);\n    } else if(r2 < fr) {\n      float temp = (fr / r2);\n      z = mul(z, temp);\n      dz = mul(dz, temp);\n    }\n}\nvoid box_fold(float fl, inout float3 z, inout float dz) {\n    z = clamp(z, -fl, fl) * 2.0 - z;\n}\nfloat sphere(float3 p, float t) {\n    return length(p)-t;\n}\nfloat torus(float3 p, float2 t) {\n    float2 q = float2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat mb(float fl, float fr, float3 z) {\n    float3 local_offset = z;\n    const float scale = -3.0;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n      box_fold65(fl, z, dr);\n      sphere_fold65(fr, z, dr);\n      z = scale * z + local_offset;\n      dr = dr * abs(scale) + 1.0;\n      float r1 = sphere65(z, 5.0);\n      float r2 = torus65(z, float2(8.0, 1));\n      float r = n < 4 ? r2 : r1;\n      float dd = r / abs(dr);\n      if (n < 3 || dd < fd) {\n        fd = dd;\n      }\n    }\n    return fd;\n}\n\n    float tm = p.z;\n    const float folding_limit = 2.3;\n    const float3  rep = float3(10.0);\n\n    float3 wrap = float3(mul(sin(tm*(0.4*float2(0.11, 0.21))), (0.7*float2(13.0, 3.0))), tm);\n    float3 wrapDeriv = normalize(float3(mul((0.4*float2(0.11, 0.21)),mul((0.7*float2(13.0, 3.0)),cos(mul((0.4*float2(0.11, 0.21)),tm)))), 1.0));\n    p.xy -= wrap.xy;\n    p -= mul(mul(wrapDeriv,dot(float3(p.xy, 0), wrapDeriv)),mul(0.5,float3(1,1,-1)));\n\n    p -= rep*float3(0.5, 0.0, 0.0);\n    p.y = mul(p.y, (1.0 + 0.1*abs(p.y)));\n    float3 i = mod3(p, rep);\n\n    const float fixed_radius2 = 4.5;\n    float fl = folding_limit + 0.3*sin(0.025*p.z+1.0)- 0.3;\n    float fr = fixed_radius2 - 3.0*cos(0.025*sqrt(0.5)*p.z-1.0);\n\n    return mb(fl, fr, p);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "WAHa_06x36",
    "OriginalCode": "float periodic(float x,float period,float dutycycle){\n    x/=period;\n    x=abs(x-floor(x)-0.5)-dutycycle*0.5;\n    return x*period;\n  }\n  float de(vec3 pos){\n    vec3 gridpos=pos-floor(pos)-0.5;\n    float r=length(pos.xy);\n    float a=atan(pos.y,pos.x);\n    a+=12.*0.3*sin(floor(r/3.0)+1.0)*sin(floor(pos.z)*13.73);\n    return min(max(max(\n    periodic(r,3.0,0.2),\n    periodic(pos.z,1.0,0.7+0.3*cos(4.))),\n    periodic(a*r,3.141592*2.0/6.0*r,0.7+0.3*cos(4.))),0.25);\n  }",
    "ConvertedCode": "// author: WAHa_06x36\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float3 gridpos=p-floor(p)-0.5;\n    float r=length(p.xy);\n    float a=atan2(p.y,p.x);\n    a+=12.0*0.3*sin(floor(r/3.0)+1.0)*sin(floor(p.z)*13.73);\n    return min(max(max(\n    (abs((r/3.0)-floor(r/3.0)-0.5)-0.2*0.5)*3.0,\n    (abs((p.z/1.0)-floor(p.z/1.0)-0.5)-(0.7+0.3*cos(4.0))*0.5)*1.0),\n    (abs((a*r/(3.141592*2.0/6.0*r))-floor(a*r/(3.141592*2.0/6.0*r))-0.5)-(0.7+0.3*cos(4.0))*0.5)*(3.141592*2.0/6.0*r)),0.25);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "dr2",
    "OriginalCode": "vec2 Rot2D (vec2 q, float a)\n  {\n    vec2 cs;\n    cs = sin (a + vec2 (0.5 * M_PI, 0.));\n    return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n  }\n  float PrBoxDf (vec3 p, vec3 b)\n  {\n    vec3 d;\n    d = abs (p) - b;\n    return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n  }\n  float de(vec3 p)\n  {\n    vec3 b;\n    float r, a;\n    const float nIt = 5., sclFac = 2.4;\n    b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n    r = length (p.xz);\n    a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;\n    p.y = mod (p.y - 4. * a + 2., 4.) - 2.;\n    p.x = mod (16. * a + 1., 2.) - 1.;\n    p.z = r - 32. / (2. * M_PI);\n    p.yz = Rot2D (p.yz, 2. * M_PI * a);\n    for (float n = 0.; n < nIt; n ++) {\n      p = abs (p);\n      p.xy = (p.x > p.y) ? p.xy : p.yx;\n      p.xz = (p.x > p.z) ? p.xz : p.zx;\n      p.yz = (p.y > p.z) ? p.yz : p.zy;\n      p = sclFac * p - b;\n      p.z += b.z * step (p.z, -0.5 * b.z);\n    }\n    return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);\n  }",
    "ConvertedCode": "// author: dr2\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat2 Rot2D (float2 q, float a)\n{\n    float2 cs;\n    cs = sin (a + float2 (0.5 * 3.14159265, 0.0));\n    return float2 (dot (q, float2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\nfloat PrBoxDf (float3 p, float3 b)\n{\n    float3 d;\n    d = abs (p) - b;\n    return min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0));\n}\n\n    float3 b;\n    float r, a;\n    float3 p_iter = p;\n    const float nIt = 5.0, sclFac = 2.4;\n    b = (sclFac - 1.0) * float3 (1.0, 1.125, 0.625);\n    r = length (p_iter.xz);\n    a = (r > 0.0) ? atan2 (p_iter.z, - p_iter.x) / (2.0 * 3.14159265) : 0.0;\n    p_iter.y = fmod (p_iter.y - 4.0 * a + 2.0, 4.0) - 2.0;\n    p_iter.x = fmod (16.0 * a + 1.0, 2.0) - 1.0;\n    p_iter.z = r - 32.0 / (2.0 * 3.14159265);\n    p_iter.yz = Rot2D (p_iter.yz, 2.0 * 3.14159265 * a);\n    for (float n = 0.0; n < nIt; n ++) {\n      p_iter = abs (p_iter);\n      p_iter.xy = (p_iter.x > p_iter.y) ? p_iter.xy : p_iter.yx;\n      p_iter.xz = (p_iter.x > p_iter.z) ? p_iter.xz : p_iter.zx;\n      p_iter.yz = (p_iter.y > p_iter.z) ? p_iter.yz : p_iter.zy;\n      p_iter = sclFac * p_iter - b;\n      p_iter.z += b.z * step (p_iter.z, -0.5 * b.z);\n    }\n    return 0.8 * PrBoxDf (p_iter, float3 (1.0)) / pow (sclFac, nIt);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "dr2",
    "OriginalCode": "vec2 Rot2D(vec2 q, float a)\n  {\n    vec2 cs;\n    cs = sin (a + vec2 (0.5 * M_PI, 0.));\n    return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n  }\n  float PrBoxDf(vec3 p, vec3 b)\n  {\n    vec3 d;\n    d = abs (p) - b;\n    return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n  }\n  float de(vec3 p)\n  {\n    vec3 b;\n    float r, a;\n    const float nIt = 5., sclFac = 2.4;\n    b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n    r = length (p.xz);\n    a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;\n    p.x = mod (16. * a + 1., 2.) - 1.;\n    p.z = r - 32. / (2. * M_PI);\n    p.yz = Rot2D (p.yz, M_PI * a);\n    for (float n = 0.; n < nIt; n ++) {\n      p = abs (p);\n      p.xy = (p.x > p.y) ? p.xy : p.yx;\n      p.xz = (p.x > p.z) ? p.xz : p.zx;\n      p.yz = (p.y > p.z) ? p.yz : p.zy;\n      p = sclFac * p - b;\n      p.z += b.z * step (p.z, -0.5 * b.z);\n    }\n    return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);\n  }",
    "ConvertedCode": "// author: dr2\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat2 Rot2D(float2 q, float a)\n{\n    float2 cs;\n    cs = sin (a + float2 (0.5 * 3.14159265, 0.0));\n    return float2 (dot (q, float2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\nfloat PrBoxDf(float3 p, float3 b)\n{\n    float3 d;\n    d = abs (p) - b;\n    return min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0));\n}\n\n    float3 b;\n    float r, a;\n    float3 p_iter = p;\n    const float nIt = 5.0, sclFac = 2.4;\n    b = (sclFac - 1.0) * float3 (1.0, 1.125, 0.625);\n    r = length (p_iter.xz);\n    a = (r > 0.0) ? atan2 (p_iter.z, - p_iter.x) / (2.0 * 3.14159265) : 0.0;\n    p_iter.x = fmod (16.0 * a + 1.0, 2.0) - 1.0;\n    p_iter.z = r - 32.0 / (2.0 * 3.14159265);\n    p_iter.yz = Rot2D (p_iter.yz, 3.14159265 * a);\n    for (float n = 0.0; n < nIt; n ++) {\n      p_iter = abs (p_iter);\n      p_iter.xy = (p_iter.x > p_iter.y) ? p_iter.xy : p_iter.yx;\n      p_iter.xz = (p_iter.x > p_iter.z) ? p_iter.xz : p_iter.zx;\n      p_iter.yz = (p_iter.y > p_iter.z) ? p_iter.yz : p_iter.zy;\n      p_iter = sclFac * p_iter - b;\n      p_iter.z += b.z * step (p_iter.z, -0.5 * b.z);\n    }\n    return 0.8 * PrBoxDf (p_iter, float3 (1.0)) / pow (sclFac, nIt);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Kali",
    "OriginalCode": "mat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n  }\n  vec4 formula(vec4 p) {\n    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n    p=p*2./clamp(dot(p.xyz,p.xyz),.15,1.)-vec4(0.5,0.5,0.8,0.);\n    p.xy*=rot(.5);\n    return p;\n  }\n  float screen(vec3 p) {\n    float d1=length(p.yz-vec2(.25,0.))-.5;\n    float d2=length(p.yz-vec2(.25,2.))-.5;\n    return min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+2.3)-.01));\n  }\n  float de(vec3 pos) {\n    vec3 tpos=pos;\n    tpos.z=abs(2.-mod(tpos.z,4.));\n    vec4 p=vec4(tpos,1.5);\n    float y=max(0.,.35-abs(pos.y-3.35))/.35;\n\n    for (int i=0; i<8; i++) {p=formula(p);}\n    float fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);\n\n    float sc=screen(tpos);\n    return min(sc,fr);\n  }",
    "ConvertedCode": "// author: Kali\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\nfloat4 formula(float4 p) {\n    p.xz = abs(p.xz+1.0)-abs(p.xz-1.0)-p.xz;\n    p=mul(p,2.0/clamp(dot(p.xyz,p.xyz),0.15,1.0))-float4(0.5,0.5,0.8,0.0);\n    p.xy=mul(p.xy, float2x2(cos(0.5),sin(0.5),-sin(0.5),cos(0.5)));\n    return p;\n}\nfloat screen(float3 p) {\n    float d1=length(p.yz-float2(0.25,0.0))-0.5;\n    float d2=length(p.yz-float2(0.25,2.0))-0.5;\n    return min(max(d1,abs(p.x-0.3)-0.01),max(d2,abs(p.x+2.3)-0.01));\n}\n\n    float3 tpos=p;\n    tpos.z=abs(2.0-fmod(tpos.z,4.0));\n    float4 p_iter=float4(tpos,1.5);\n    float y=max(0.0,0.35-abs(p.y-3.35))/0.35;\n\n    for (int i=0; i<8; i++) {p_iter=formula(p_iter);}\n    float fr=max(-tpos.x-4.0,(length(max(float2(0.0),p_iter.yz-3.0)))/p_iter.w);\n\n    float sc=screen(tpos);\n    return min(sc,fr);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "glkt",
    "OriginalCode": "float smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n  }\n  float noise(vec3 p){\n    vec3 np = normalize(p);\n\n    float a = 0.1*snoise2D(np.xy*10.);\n    float b = 0.1*snoise2D(0.77+np.yz*10.);\n\n    a = mix(a,.5,abs(np.x));\n    b = mix(b,.5,abs(np.z));\n    return mix(a+b-.4,.5,abs(np.y)/2.);\n  }\n  float de(vec3 p){\n    float d = (-1.*length(p)+3.)+1.5*noise(p);\n    d = min(d, (length(p)-1.5)+1.5*noise(p) );\n    float m = 1.5; float s = .03;\n    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);\n    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );\n    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );\n    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );\n    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );\n    return d;\n  }",
    "ConvertedCode": "// author: glkt\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader uses snoise2D which is not a standard function.\n// You will need to provide an implementation for snoise2D for this to compile.\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return lerp( b, a, h ) - k*h*(1.0-h);\n}\nfloat noise(float3 p){\n    float3 np = normalize(p);\n\n    float a = 0.1*snoise2D(np.xy*10.0);\n    float b = 0.1*snoise2D(0.77+np.yz*10.0);\n\n    a = lerp(a,0.5,abs(np.x));\n    b = lerp(b,0.5,abs(np.z));\n    return lerp(a+b-0.4,0.5,abs(np.y)/2.0);\n}\n\n    float d = (-1.0*length(p)+3.0)+1.5*noise(p);\n    d = min(d, (length(p)-1.5)+1.5*noise(p) );\n    float m = 1.5; float s = 0.03;\n    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*0.2)-0.07 ) , m);\n    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.0)-0.07 ), m );\n    d = smin(d, max( abs(p.z-p.y*0.4)-s, abs(p.x-p.y*0.2)-0.07 ), m );\n    d = smin(d, max( abs(p.z*0.2-p.y)-s, abs(p.x+p.z)-0.07 ), m );\n    d = smin(d, max( abs(p.z*-0.2+p.y)-s, abs(-p.x+p.z)-0.07 ), m );\n    return d;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "unconed",
    "OriginalCode": "vec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n  }\n  vec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n  }\n  vec4 invertRadius(vec4 z, float radius2, float limit) {\n    float r2 = dot(z.xyz, z.xyz);\n    float f = clamp(radius2 / r2, 1., limit);\n    return z * f;\n  }\n  vec4 affine(vec4 z, float factor, vec3 offset) {\n    z.xyz *= factor;\n    z.xyz += offset;\n    z.w *= abs(factor);\n    return z;\n  }\n  vec4 mandel(vec4 z, vec3 offset) {\n    float x = z.x;\n    float y = z.y;\n    z.w = 2. * length(z.xy) * z.w + 1.;\n    z.x = x*x - y*y + offset.x;\n    z.y = 2.*x*y + offset.y;\n    return z;\n  }\n  vec4 invert(vec4 z, float factor) {\n    float r2 = dot(z.xyz, z.xyz);\n    float f = factor / r2;\n    return z * f;\n  }\n  vec4 rotateXY(vec4 z, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 m = mat2(c, s, -s, c);\n    return vec4(m * z.xy, z.zw);\n  }\n  vec4 rotateXZ(vec4 z, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 m = mat2(c, s, -s, c);\n    vec2 r = m * z.xz;\n    return vec4(r.x, z.y, r.y, z.w);\n  }\n  vec4 shiftXY(vec4 z, float angle, float radius) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec4(vec2(c, s) * radius + z.xy, z.zw);\n  }\n  float de(vec3 p) {\n    vec4 z = vec4(p, 1.0);\n    float t = 344. * .2; // change this number for different shapes\n    vec3 vo1 = vec3(sin(t * .1), cos(t * .0961), sin(t * .017)) * 1.1;\n    vec3 vo2 = vec3(cos(t * .07), sin(t * .0533), sin(t * .138)) * 1.1;\n    vec3 vo3 = vec3(sin(t * .031), sin(t * .0449), cos(t * .201)) * 1.1;\n\n    z = invertRadius_73(z, 10.0, 1.5);\n    z = invertRadius_73(z, 10.0*10.0, 2.0);\n    z = rotateXY(z, t);\n    z = fold1(z);\n    z = rotateXZ(z, t * 1.112);\n    z.xyz += vo3;\n    z = fold2(z);\n    z.xyz += vo1;\n    z = affine(z, -1.5, p);\n    z = invertRadius(z, 4.0*4.0, 2.0);\n    z = affine(z, -1.5, p);\n    z = rotateXY(z, t * .881);\n    z = fold1(z);\n    z = rotateXZ(z, t * .783);\n    z = fold1(z);\n    z = affine_73(z, -1.5, p);\n    z = invertRadius(z, 10.0*10.0, 3.0);\n    z = fold1(z);\n    z = fold1(z);\n    z = affine(z, -1.5, p);\n    z = invertRadius(z, 10.0*10.0, 2.0);\n\n    vec3 po = vec3(0.0, 0.0, 0.0);\n    vec3 box = abs(z.xyz);\n    float d1 = (max(box.x - 2.0, max(box.y - 2.0, box.z - 10.0))) / z.w;\n    float d2 = (max(box.x - 20.0, max(box.y - .5, box.z - .5))) / z.w;\n    float d3 = min(d1, d2);\n    return d3;\n  }",
    "ConvertedCode": "// author: unconed\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat4 fold1(float4 z) {\n    float3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return float4(p, z.w);\n}\nfloat4 fold2(float4 z) {\n    float3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return float4(p * 2.0, 2.0 * z.w);\n}\nfloat4 invertRadius(float4 z, float radius2, float limit) {\n    float r2 = dot(z.xyz, z.xyz);\n    float f = clamp(radius2 / r2, 1.0, limit);\n    return z * f;\n}\nfloat4 affine(float4 z, float factor, float3 offset) {\n    z.xyz=mul(z.xyz, factor);\n    z.xyz += offset;\n    z.w=mul(z.w, abs(factor));\n    return z;\n}\nfloat4 mandel(float4 z, float3 offset) {\n    float x = z.x;\n    float y = z.y;\n    z.w = 2.0 * length(z.xy) * z.w + 1.0;\n    z.x = x*x - y*y + offset.x;\n    z.y = 2.0*x*y + offset.y;\n    return z;\n}\nfloat4 invert(float4 z, float factor) {\n    float r2 = dot(z.xyz, z.xyz);\n    float f = factor / r2;\n    return z * f;\n}\nfloat4 rotateXY(float4 z, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float2x2 m = float2x2(c, s, -s, c);\n    return float4(mul(m, z.xy), z.zw);\n}\nfloat4 rotateXZ(float4 z, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float2x2 m = float2x2(c, s, -s, c);\n    float2 r = mul(m, z.xz);\n    return float4(r.x, z.y, r.y, z.w);\n}\nfloat4 shiftXY(float4 z, float angle, float radius) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return float4(mul(float2(c, s), radius) + z.xy, z.zw);\n}\n\n    float4 z = float4(p, 1.0);\n    float t = 344.0 * 0.2; // change this number for different shapes\n    float3 vo1 = mul(float3(sin(t * 0.1), cos(t * 0.0961), sin(t * 0.017)), 1.1);\n    float3 vo2 = mul(float3(cos(t * 0.07), sin(t * 0.0533), sin(t * 0.138)), 1.1);\n    float3 vo3 = mul(float3(sin(t * 0.031), sin(t * 0.0449), cos(t * 0.201)), 1.1);\n\n    z = invertRadius_73(z, 10.0, 1.5);\n    z = invertRadius_73(z, 10.0*10.0, 2.0);\n    z = rotateXY(z, t);\n    z = fold1(z);\n    z = rotateXZ(z, t * 1.112);\n    z.xyz += vo3;\n    z = fold2(z);\n    z.xyz += vo1;\n    z = affine(z, -1.5, p);\n    z = invertRadius(z, 4.0*4.0, 2.0);\n    z = affine(z, -1.5, p);\n    z = rotateXY(z, t * 0.881);\n    z = fold1(z);\n    z = rotateXZ(z, t * 0.783);\n    z = fold1(z);\n    z = affine_73(z, -1.5, p);\n    z = invertRadius(z, 10.0*10.0, 3.0);\n    z = fold1(z);\n    z = fold1(z);\n    z = affine(z, -1.5, p);\n    z = invertRadius(z, 10.0*10.0, 2.0);\n\n    float3 po = float3(0.0, 0.0, 0.0);\n    float3 box = abs(z.xyz);\n    float d1 = (max(box.x - 2.0, max(box.y - 2.0, box.z - 10.0))) / z.w;\n    float d2 = (max(box.x - 20.0, max(box.y - 0.5, box.z - 0.5))) / z.w;\n    float d3 = min(d1, d2);\n    return d3;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "lewiz",
    "OriginalCode": "void sphereFold(inout vec3 z, inout float dz){\n    float r2 = dot(z,z);\n    if (r2 < 0.5){\n      float temp = 2.0;\n      z *= temp;\n      dz*= temp;\n    }else if (r2 < 1.0){\n      float temp = 1.0 / r2;\n      z *= temp; dz*= temp;\n    }\n  }\n  void boxFold(inout vec3 z, inout float dz){\n    z = clamp(z, -1.0, 1.0) * 2.0 - z;\n  }\n  float de(vec3 z){\n    float scale = 2.0;\n    vec3 offset = z;\n    float dr = 1.0;\n    for (int n = 0; n < 10; n++){\n      boxFold(z,dr);\n      sphereFold(z,dr);\n      z = scale * z + offset;\n      dr = dr * abs(scale) + 1.0;\n    }\n    float r = length(z);\n    return r / abs(dr);\n  }",
    "ConvertedCode": "// author: lewiz\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: N/A\n// C: N/A\n// Offset: N/A\nvoid sphereFold(inout float3 z, inout float dz){\n    float r2 = dot(z,z);\n    if (r2 < 0.5){\n      float temp = 2.0;\n      z = mul(z, temp);\n      dz=mul(dz, temp);\n    }else if (r2 < 1.0){\n      float temp = 1.0 / r2;\n      z = mul(z, temp); dz=mul(dz, temp);\n    }\n}\nvoid boxFold(inout float3 z, inout float dz){\n    z = clamp(z, -1.0, 1.0) * 2.0 - z;\n}\n\n    float3 z = p;\n    float scale = A;\n    float3 local_offset = z;\n    float dr = 1.0;\n    for (int n = 0; n < 10; n++){\n      boxFold(z,dr);\n      sphereFold(z,dr);\n      z = scale * z + local_offset;\n      dr = dr * abs(scale) + 1.0;\n    }\n    float r = length(z);\n    return r / abs(dr);",
    "A": 2.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "raziel",
    "OriginalCode": "float op_u(float d1, float d2){\n          return (d1 < d2) ? d1 : d2;\n  }\n  void sphere_fold(inout vec3 p, inout float dr, float m_rad_sq, float f_rad_sq, float m_rad_sq_inv){\n    float r_sq = dot(p, p);\n    if (r_sq < m_rad_sq){\n      float t = f_rad_sq * m_rad_sq_inv;\n      p *= t;\n      dr *= t;\n    }\n    else if (r_sq < f_rad_sq){\n      float t = f_rad_sq / r_sq;\n      p *= t;\n      dr *= t;\n    }\n  }\n  void box_fold(inout vec3 p, float fold_limit){\n    p = clamp(p, -fold_limit, fold_limit) * 2.0 - p;\n  }\n  // estimators return (dist, mat_id, custom_value)\n  float estimator_mandelbox(vec3 p, float scale, float m_rad_sq, float f_rad_sq, float fold_limit){\n    vec3 off = p;\n    float dr = 1.0;\n    float mrs_inv = 1.0 / m_rad_sq;\n    for (int i = 0; i < 10; ++i){\n      box_fold(p, fold_limit);\n      sphere_fold(p, dr, m_rad_sq, f_rad_sq, mrs_inv);\n\n      p = scale * p + off;\n      dr = dr * abs(scale) + 1.0;\n      vec3 ot = p - vec3(0.5);\n    }\n    return length(p) / abs(dr);\n  }\n  vec3 mod_pos(vec3 p, float a, float b){\n    p.zx = mod(p.zx, a) - b;\n    return p;\n  }\n  float de(vec3 p){\n    vec3 p_mb = mod_pos_77(p, 4.4, 2.2);\n    float res_mb = estimator_mandelbox(p, -2.5, 0.1, 2.5, 1.0);\n    vec3 p_pl = p;\n    p_pl.y += 4.0;\n    p_pl = mod_pos(p_pl, 2.0, 1.0);\n    float res_pl = estimator_mandelbox(p_pl, -1.5, 0.3, 2.9, 1.0);\n\n    return op_u(res_mb, res_pl);\n  }",
    "ConvertedCode": "// author: raziel\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat op_u(float d1, float d2){\n          return (d1 < d2) ? d1 : d2;\n}\nvoid sphere_fold(inout float3 p, inout float dr, float m_rad_sq, float f_rad_sq, float m_rad_sq_inv){\n    float r_sq = dot(p, p);\n    if (r_sq < m_rad_sq){\n      float t = f_rad_sq * m_rad_sq_inv;\n      p = mul(p, t);\n      dr = mul(dr, t);\n    }\n    else if (r_sq < f_rad_sq){\n      float t = f_rad_sq / r_sq;\n      p = mul(p, t);\n      dr = mul(dr, t);\n    }\n}\nvoid box_fold(inout float3 p, float fold_limit){\n    p = clamp(p, -fold_limit, fold_limit) * 2.0 - p;\n}\n// estimators return (dist, mat_id, custom_value)\nfloat estimator_mandelbox(float3 p, float scale, float m_rad_sq, float f_rad_sq, float fold_limit){\n    float3 off = p;\n    float dr = 1.0;\n    float mrs_inv = 1.0 / m_rad_sq;\n    for (int i = 0; i < 10; ++i){\n      box_fold(p, fold_limit);\n      sphere_fold(p, dr, m_rad_sq, f_rad_sq, mrs_inv);\n\n      p = scale * p + off;\n      dr = dr * abs(scale) + 1.0;\n      float3 ot = p - float3(0.5);\n    }\n    return length(p) / abs(dr);\n}\nfloat3 mod_pos(float3 p, float a, float b){\n    p.zx = fmod(p.zx, a) - b;\n    return p;\n}\n\n    float3 p_mb = mod_pos_77(p, 4.4, 2.2);\n    float res_mb = estimator_mandelbox(p, -2.5, 0.1, 2.5, 1.0);\n    float3 p_pl = p;\n    p_pl.y += 4.0;\n    p_pl = mod_pos(p_pl, 2.0, 1.0);\n    float res_pl = estimator_mandelbox(p_pl, -1.5, 0.3, 2.9, 1.0);\n\n    return op_u(res_mb, res_pl);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "gaziya5 aka gaz",
    "OriginalCode": "#define opRepEven(p,s) mod(p,s)-0.5*s\n  #define opRepOdd(p,s) p-s*round(p/s)\n  #define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n  float lpNorm_83(vec3 p, float n){\n          p = pow(abs(p), vec3(n));\n          return pow(p.x+p.y+p.z, 1.0/n);\n  }\n  vec2 pSFold_83(vec2 p,float n){\n    float h=floor(log2(n)),a =6.2831*exp2(h)/n;\n    for(float i=0.0; i < h+2.0; i++){\n      vec2 v = vec2(-cos(a),sin(a));\n      float g= dot(p,v);\n      p-= (g - sqrt(g * g + 5e-3))*v;\n      a*=0.5;\n    }\n    return p;\n  }\n  vec2 sFold45_83(vec2 p, float k){\n    vec2 v = vec2(-1,1)*0.7071;\n    float g= dot(p,v);\n    return p-(g-sqrt(g*g+k))*v;\n  }\n  float frameBox_83(vec3 p, vec3 s, float r){\n    p = abs(p)-s;\n    p.yz=sFold45_83(p.yz, 1e-3);\n    p.xy=sFold45_83(p.xy, 1e-3);\n    p.x = max(0.0,p.x);\n    return lpNorm_83(p,5.0)-r;\n  }\n  float sdRoundBox_83( vec3 p, vec3 b, float r ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  }\n  float deObj_83(vec3 p){\n    return min(sdRoundBox_83(p,vec3(0.3),0.05),frameBox_83(p,vec3(0.8),0.1));\n  }\n  float de(vec3 p){\n    float de=1.0;\n    // p.z-=iTime*1.1;\n    vec3 q= p;\n    p.xy=pSFold_83(-p.xy,3.0);\n    p.y-=8.5;\n    p.xz=opRepEven(p.xz,8.5);\n    float de1=length(p.yz)-1.;\n    de=min(de,de1);\n    p.xz=pSFold_83(p.xz,8.0);\n    p.z-=2.0;\n    float rate=0.5;\n    float s=1.0;\n    for(int i=0;i<3;i++){\n      p.xy=abs(p.xy)-.8;\n      p.xz=abs(p.xz)-0.5;\n      p.xy*=rot(0.2);\n      p.xz*=rot(-0.9);\n      s*=rate;\n      p*=rate;\n      de=min(de,deObj_83(p/s));\n    }\n    q.z=opRepOdd(q.z,8.5);\n    float de0=length(q)-1.5;\n    de=min(de,de0);\n    return de;\n  }",
    "ConvertedCode": "// author: gaziya5 aka gaz\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat lpNorm_83(float3 p, float n){\n          p = pow(abs(p), float3(n));\n          return pow(p.x+p.y+p.z, 1.0/n);\n}\nfloat2 pSFold_83(float2 p,float n){\n    float h=floor(log2(n)),a =6.2831*exp2(h)/n;\n    for(float i=0.0; i < h+2.0; i++){\n      float2 v = float2(-cos(a),sin(a));\n      float g= dot(p,v);\n      p-= (g - sqrt(g * g + 5e-3))*v;\n      a=mul(a,0.5);\n    }\n    return p;\n}\nfloat2 sFold45_83(float2 p, float k){\n    float2 v = float2(-1,1)*0.7071;\n    float g= dot(p,v);\n    return p-(g-sqrt(g*g+k))*v;\n}\nfloat frameBox_83(float3 p, float3 s, float r){\n    p = abs(p)-s;\n    p.yz=sFold45_83(p.yz, 1e-3);\n    p.xy=sFold45_83(p.xy, 1e-3);\n    p.x = max(0.0,p.x);\n    return lpNorm_83(p,5.0)-r;\n}\nfloat sdRoundBox_83( float3 p, float3 b, float r ){\n    float3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat deObj_83(float3 p){\n    return min(sdRoundBox_83(p,float3(0.3),0.05),frameBox_83(p,float3(0.8),0.1));\n}\n\n    float de=1.0;\n    float3 p_iter = p;\n    // p_iter.z-=iTime*1.1;\n    float3 q= p_iter;\n    p_iter.xy=pSFold_83(-p_iter.xy,3.0);\n    p_iter.y-=8.5;\n    p_iter.xz=fmod(p_iter.xz,8.5)-0.5*8.5;\n    float de1=length(p_iter.yz)-1.0;\n    de=min(de,de1);\n    p_iter.xz=pSFold_83(p_iter.xz,8.0);\n    p_iter.z-=2.0;\n    float rate=0.5;\n    float s=1.0;\n    for(int i=0;i<3;i++){\n      p_iter.xy=abs(p_iter.xy)-0.8;\n      p_iter.xz=abs(p_iter.xz)-0.5;\n      p_iter.xy=mul(p_iter.xy, float2x2(cos(0.2),sin(0.2),-sin(0.2),cos(0.2)));\n      p_iter.xz=mul(p_iter.xz, float2x2(cos(-0.9),sin(-0.9),-sin(-0.9),cos(-0.9)));\n      s=mul(s,rate);\n      p_iter=mul(p_iter,rate);\n      de=min(de,deObj_83(p_iter/s));\n    }\n    q.z=q.z-8.5*round(q.z/8.5);\n    float de0=length(q)-1.5;\n    de=min(de,de0);\n    return de;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "gaziya5 aka gaz",
    "OriginalCode": "vec3 rot(vec3 p,vec3 a,float t){\n          a=normalize(a);\n          vec3 v = cross(a,p),u = cross(v,a);\n          return u * cos(t) + v * sin(t) + a * dot(p, a);\n  }\n  float lpNorm(vec2 p, float n){\n          p = pow(abs(p), vec2(n));\n          return pow(p.x+p.y, 1.0/n);\n  }\n  float sdTorus( vec3 p, vec2 t ){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n  }\n  float smin( float a, float b, float k ) {\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n  }\n  float deTetra(vec3 p){\n          vec2 g=vec2(-1,1)*0.577;\n          return pow(\n                  pow(max(0.0,dot(p,g.xxx)),8.0)\n                  +pow(max(0.0,dot(p,g.xyy)),8.0)\n                  +pow(max(0.0,dot(p,g.yxy)),8.0)\n                  +pow(max(0.0,dot(p,g.yyx)),8.0),\n                  0.125);\n  }\n  float deStella(vec3 p){\n    p=rot(p,vec3(1,2,3),time*3.0);\n          return smin(deTetra_85(p)-1.0,deTetra(-p)-1.0,0.05);\n  }\n  #define Circle 2.2\n  vec2 hash2( vec2 p ){\n    p = mod(p, Circle*2.0);\n          return fract(sin(vec2(\n          dot(p,vec2(127.1,311.7)),\n          dot(p,vec2(269.5,183.3))\n      ))*43758.5453);\n  }\n  vec3 voronoi(vec2 x){\n    x*=Circle;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 mg, mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n      vec2 g = vec2(float(i),float(j));\n      vec2 o = hash2( n + g );\n      o = 0.5 + 0.5*sin( time*0.3 + 6.2831*o );\n      vec2 r = g + o - f;\n      float d = dot(r,r);\n      if( d < md ){\n        md = d;\n        mr = r;\n        mg = g;\n      }\n    }\n    md = 8.0;\n    for( int j=-2; j <= 2; j++ )\n    for( int i=-2; i <= 2; i++ ){\n      vec2 g = mg + vec2(float(i),float(j));\n      vec2 o = hash2( n + g );\n      o = 0.5 + 0.5*sin( time*0.3 + 6.2831*o );\n      vec2 r = g + o - f;\n      if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( md, mr );\n  }\n  float voronoiTorus(vec3 p){\n    vec2 size = vec2(12,5);\n    vec2 q = vec2(length(p.xz) - size.x, p.y);\n    vec2 uv=vec2(atan(p.z, p.x),atan(q.y, q.x))/3.1415;\n    vec3 vr=voronoi(uv*vec2(20,8));\n    vec2 p2=vec2(lpNorm(vr.yz,12.0)-0.5, sdTorus(p,size));\n    return lpNorm(p2,5.0)-0.1;\n  }\n  float fractal(vec3 p)\n  {\n    vec3 offset = vec3(6,0,0);\n    float de = min(voronoiTorus(p-offset),voronoiTorus(p.xzy+offset));\n    vec3 co = vec3(cos(time),0,sin(time))*10.0;\n    float s1= abs(sin(time))*3.0+2.0;\n    float deSG = min(deStella((p-co-offset)/s1),deStella((p-(co-offset).xzy)/s1))*s1;\n    float deS = min(deStella(p-co-offset),deStella(p-(co-offset).xzy));\n    de=min(de,deS);\n    return de;\n  }",
    "ConvertedCode": "// author: gaziya5 aka gaz\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.0 (Mapped from 'time')\n// B: 0.0 (Mapped from 'time')\n// C: 0.0 (Mapped from 'time')\n// Offset: N/A\nfloat3 rot(float3 p,float3 a,float t){\n          a=normalize(a);\n          float3 v = cross(a,p),u = cross(v,a);\n          return u * cos(t) + v * sin(t) + a * dot(p, a);\n}\nfloat lpNorm(float2 p, float n){\n          p = pow(abs(p), float2(n));\n          return pow(p.x+p.y, 1.0/n);\n}\nfloat sdTorus( float3 p, float2 t ){\n    float2 q = float2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat smin( float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return lerp(b, a, h) - k*h*(1.0-h);\n}\nfloat deTetra(float3 p){\n          float2 g=float2(-1,1)*0.577;\n          return pow(\n                  pow(max(0.0,dot(p,g.xxx)),8.0)\n                  +pow(max(0.0,dot(p,g.xyy)),8.0)\n                  +pow(max(0.0,dot(p,g.yxy)),8.0)\n                  +pow(max(0.0,dot(p,g.yyx)),8.0),\n                  0.125);\n}\nfloat deStella(float3 p){\n    p=rot(p,float3(1,2,3),A*3.0);\n          return smin(deTetra_85(p)-1.0,deTetra(-p)-1.0,0.05);\n}\nfloat2 hash2( float2 p ){\n    p = fmod(p, 2.2*2.0);\n          return frac(sin(float2(\n          dot(p,float2(127.1,311.7)),\n          dot(p,float2(269.5,183.3))\n      ))*43758.5453);\n}\nfloat3 voronoi(float2 x){\n    x=mul(x,2.2);\n    float2 n = floor(x);\n    float2 f = frac(x);\n    float2 mg, mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n      float2 g = float2(float(i),float(j));\n      float2 o = hash2( n + g );\n      o = 0.5 + 0.5*sin( B*0.3 + 6.2831*o );\n      float2 r = g + o - f;\n      float d = dot(r,r);\n      if( d < md ){\n        md = d;\n        mr = r;\n        mg = g;\n      }\n    }\n    md = 8.0;\n    for( int j=-2; j <= 2; j++ )\n    for( int i=-2; i <= 2; i++ ){\n      float2 g = mg + float2(float(i),float(j));\n      float2 o = hash2( n + g );\n      o = 0.5 + 0.5*sin( C*0.3 + 6.2831*o );\n      float2 r = g + o - f;\n      if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return float3( md, mr );\n}\nfloat voronoiTorus(float3 p){\n    float2 size = float2(12,5);\n    float2 q = float2(length(p.xz) - size.x, p.y);\n    float2 uv=float2(atan2(p.z, p.x),atan2(q.y, q.x))/3.1415;\n    float3 vr=voronoi(uv*float2(20,8));\n    float2 p2=float2(lpNorm(vr.yz,12.0)-0.5, sdTorus(p,size));\n    return lpNorm(p2,5.0)-0.1;\n}\n\n    float3 local_offset = float3(6,0,0);\n    float de = min(voronoiTorus(p-local_offset),voronoiTorus(p.xzy+local_offset));\n    float3 co = mul(float3(cos(A),0,sin(A)),10.0);\n    float s1= abs(sin(A))*3.0+2.0;\n    float deSG = min(deStella((p-co-local_offset)/s1),deStella((p-(co-local_offset).xzy)/s1))*s1;\n    float deS = min(deStella(p-co-local_offset),deStella(p-(co-local_offset).xzy));\n    de=min(de,deS);\n    return de;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float maxcomp(in vec3 p ){\n          return max(p.x,max(p.y,p.z));\n  }\n\n  float sdBox( vec3 p, vec3 b ){\n    vec3  di = abs(p) - b;\n    float mc = maxcomp(di);\n    return min(mc,length(max(di,0.0)));\n  }\n\n  float de(vec3 p){\n    vec3 w = p; vec3 q = p;\n    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;\n    float d = sdBox(q,vec3(1.0));\n    float s = 1.0;\n    for( int m=0; m<7; m++ ){\n      float h = float(m)/6.0;\n      p =  q.yzx - 0.5*sin( 1.5*p.x + 6.0 + p.y*3.0 + float(m)*5.0 + vec3(1.0,0.0,0.0));\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n      d = max( c, d );\n    }\n    return d*0.5;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat maxcomp(in float3 p ){\n          return max(p.x,max(p.y,p.z));\n}\nfloat sdBox( float3 p, float3 b ){\n    float3  di = abs(p) - b;\n    float mc = maxcomp(di);\n    return min(mc,length(max(di,0.0)));\n}\n\n    float3 w = p; float3 q = p;\n    float3 p_iter = p;\n    q.xz = fmod( q.xz+1.0, 2.0 ) -1.0;\n    float d = sdBox(q,float3(1.0));\n    float s = 1.0;\n    for( int m=0; m<7; m++ ){\n      float h = float(m)/6.0;\n      p_iter =  q.yzx - 0.5*sin( 1.5*p_iter.x + 6.0 + p_iter.y*3.0 + float(m)*5.0 + float3(1.0,0.0,0.0));\n      float3 a = fmod( p_iter*s, 2.0 )-1.0;\n      s = mul(s, 3.0);\n      float3 r = abs(1.0 - 3.0*abs(a));\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n      d = max( c, d );\n    }\n    return d*0.5;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "adapted from code by sdfgeoff",
    "OriginalCode": "float sdRoundBox( vec3 p, vec3 b, float r ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  }\n\n  float df(vec3 co) {\n    float rad = clamp(co.z * 0.05 + 0.45, 0.1, 0.3);\n    co = mod(co, vec3(1.0)) - 0.5;\n    return sdRoundBox(co, vec3(rad, rad, 0.3), 0.1);\n  }\n\n  float de(vec3 p){\n    float body = 999.0;\n    float scale = 0.2;\n    vec3 co = p;\n    mat4 m = mat4(\n    vec4(0.6373087, -0.0796581,  0.7664804, 0.0),\n    vec4(0.2670984,  0.9558195, -0.1227499, 0.0),\n    vec4(-0.7228389,  0.2829553,  0.6304286, 0.0),\n    vec4(0.1, 0.6, 0.2, 0.0));\n    for (int i=0; i<3; i++) {\n      co = (m * vec4(co, float(i))).xyz;\n      scale *= (3.0);\n      float field = df(co * scale) / scale;\n      body = smin_op(body, field, 0.05);\n    }\n    return -body;\n  }",
    "ConvertedCode": "// author: adapted from code by sdfgeoff\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader uses smin_op which is not a standard function.\n// You will need to provide an implementation for smin_op for this to compile.\n\nfloat sdRoundBox( float3 p, float3 b, float r ){\n    float3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat df(float3 co) {\n    float rad = clamp(co.z * 0.05 + 0.45, 0.1, 0.3);\n    co = fmod(co, float3(1.0)) - 0.5;\n    return sdRoundBox(co, float3(rad, rad, 0.3), 0.1);\n}\n\n    float body = 999.0;\n    float scale = 0.2;\n    float3 co = p;\n    float4x4 m = float4x4(\n    float4(0.6373087, -0.0796581,  0.7664804, 0.0),\n    float4(0.2670984,  0.9558195, -0.1227499, 0.0),\n    float4(-0.7228389,  0.2829553,  0.6304286, 0.0),\n    float4(0.1, 0.6, 0.2, 0.0));\n    for (int i=0; i<3; i++) {\n      co = (mul(m, float4(co, float(i)))).xyz;\n      scale = mul(scale, (3.0));\n      float field = df(co * scale) / scale;\n      body = smin_op(body, field, 0.05);\n    }\n    return -body;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "neozhaoliang",
    "OriginalCode": "float mandelbulb(vec3 p)\n  {\n    p /= 1.192;\n    p.xyz = p.xzy;\n    vec3 z = p;\n    vec3 dz = vec3(0.0);\n    float dr = 1.0;\n    float power = 8.0;\n    float r, theta, phi;\n    for (int i = 0; i < 7; i++)\n    {\n      r = length(z);\n      if (r > 2.0)\n          break;\n      float theta = atan(z.y / z.x);\n      float phi = asin(z.z / r);\n      dr = pow(r, power - 1.0) * power * dr + 1.0;\n      r = pow(r, power);\n      theta = theta * power;\n      phi = phi * power;\n      z = r * vec3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi)) + p;\n    }\n    return 0.5 * log(r) * r / dr;\n  }\n\n  float sdSponge(vec3 z)\n  {\n    for(int i = 0; i < 9; i++)\n    {\n      z = abs(z);\n      z.xy = (z.x < z.y) ? z.yx : z.xy;\n      z.xz = (z.x < z.z) ? z.zx : z.xz;\n      z.zy = (z.y < z.z) ? z.yz : z.zy;\n      z = z * 3.0 - 2.0;\n      z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    z = abs(z) - vec3(1.0);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0));\n    return dis * 0.6 * pow(3.0, -float(9));\n  }\n\n  float de(vec3 p)\n  {\n    float d1 = mandelbulb(p);\n    float d2 = sdSponge(p);\n    return max(d1, d2);\n  }",
    "ConvertedCode": "// author: neozhaoliang\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat mandelbulb(float3 p)\n{\n    p /= 1.192;\n    p.xyz = p.xzy;\n    float3 z = p;\n    float3 dz = float3(0.0);\n    float dr = 1.0;\n    float power = 8.0;\n    float r, theta, phi;\n    for (int i = 0; i < 7; i++)\n    {\n      r = length(z);\n      if (r > 2.0)\n          break;\n      float theta = atan2(z.y, z.x);\n      float phi = asin(z.z / r);\n      dr = pow(r, power - 1.0) * power * dr + 1.0;\n      r = pow(r, power);\n      theta = theta * power;\n      phi = phi * power;\n      z = r * float3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi)) + p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\nfloat sdSponge(float3 z)\n{\n    for(int i = 0; i < 9; i++)\n    {\n      z = abs(z);\n      z.xy = (z.x < z.y) ? z.yx : z.xy;\n      z.xz = (z.x < z.z) ? z.zx : z.xz;\n      z.zy = (z.y < z.z) ? z.yz : z.zy;\n      z = z * 3.0 - 2.0;\n      z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    z = abs(z) - float3(1.0);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0));\n    return dis * 0.6 * pow(3.0, -float(9));\n}\n\n    float d1 = mandelbulb(p);\n    float d2 = sdSponge(p);\n    return max(d1, d2);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "plento",
    "OriginalCode": "float sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n  }\n\n  vec2 rotate(vec2 k,float t){\n    return vec2(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);\n  }\n\n  float de(vec3 pos){\n    vec3 b = vec3(0.9 , 4.5, 0.70);\n    float p = sin(pos.z * 0.1) * 2.0;\n\n    pos = vec3(rotate(pos.xy, p), pos.z);\n    pos.y += 1.2;\n    pos = mod(pos, b) -0.5 * b;\n    pos.x *= sin(length(pos * 1.8) * 2.0) * 1.4;\n\n    return sdBox(pos - vec3(0.0, 0.0, 0.0), vec3(0.4));\n  }",
    "ConvertedCode": "// author: plento\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.9\n// B: 4.5\n// C: 0.7\n// Offset: N/A\nfloat sdBox( float3 p, float3 b ){\n    float3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n    float3 b = float3(A , B, C);\n    float3 p_iter = p;\n    float p_val = sin(p_iter.z * 0.1) * 2.0;\n\n    p_iter = float3((float2(cos(p_val) * p_iter.xy.x - sin(p_val) * p_iter.xy.y, sin(p_val) * p_iter.xy.x + cos(p_val) * p_iter.xy.y)), p_iter.z);\n    p_iter.y += 1.2;\n    p_iter = fmod(p_iter, b) -0.5 * b;\n    p_iter.x=mul(p_iter.x, sin(length(p_iter * 1.8) * 2.0) * 1.4);\n\n    return sdBox(p_iter - float3(0.0, 0.0, 0.0), float3(0.4));",
    "A": 0.9,
    "B": 4.5,
    "C": 0.7,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "russ",
    "OriginalCode": "float sdHexPrism( vec3 p, vec2 h ){\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n         length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n         p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  }\n\n  float sdCrossHex( in vec3 p ){\n    float sdh1= sdHexPrism(  p-vec3(0.0), vec2(1.0,1.0) );\n    float sdh2= sdHexPrism(  p-vec3(0.0), vec2(0.5,1.5) );\n    float sdh3= sdHexPrism(  p.xzy-vec3(0.0), vec2(0.5,1.1) );\n    float sdh4= sdHexPrism(  p.yzx-vec3(0.0), vec2(0.5,1.5) );\n    return max( max( max(sdh1, -sdh2), -sdh3),-sdh4);\n  }\n\n  float sdCrossRep(vec3 p) {\n    vec3 q = mod(p + 1.0, 2.0) - 1.0;\n    return sdCrossHex(q);\n  }\n\n  float sdCrossRepScale(vec3 p, float s) {\n    return sdCrossRep(p * s) / s;\n  }\n\n  float de(vec3 p) {\n    float scale = 3.025;\n    float dist= sdHexPrism(p, vec2(1.0,2.0) );\n    for (int i = 0; i < 5; i++) {\n      dist = max(dist, -sdCrossRepScale(p, scale));\n      scale *= 3.0;\n    }\n    return dist;\n  }",
    "ConvertedCode": "// author: russ\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat sdHexPrism( float3 p, float2 h ){\n    const float3 k = float3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    float2 d = float2(\n         length(p.xy-float2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n         p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCrossHex( in float3 p ){\n    float sdh1= sdHexPrism(  p-float3(0.0), float2(1.0,1.0) );\n    float sdh2= sdHexPrism(  p-float3(0.0), float2(0.5,1.5) );\n    float sdh3= sdHexPrism(  p.xzy-float3(0.0), float2(0.5,1.1) );\n    float sdh4= sdHexPrism(  p.yzx-float3(0.0), float2(0.5,1.5) );\n    return max( max( max(sdh1, -sdh2), -sdh3),-sdh4);\n}\nfloat sdCrossRep(float3 p) {\n    float3 q = fmod(p + 1.0, 2.0) - 1.0;\n    return sdCrossHex(q);\n}\nfloat sdCrossRepScale(float3 p, float s) {\n    return sdCrossRep(p * s) / s;\n}\n\n    float scale = 3.025;\n    float dist= sdHexPrism(p, float2(1.0,2.0) );\n    for (int i = 0; i < 5; i++) {\n      dist = max(dist, -sdCrossRepScale(p, scale));\n      scale = mul(scale, 3.0);\n    }\n    return dist;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "russ",
    "OriginalCode": "float sdTriPrism( vec3 p, vec2 h ){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n  }\n\n  float sdCrossHex( in vec3 p ){\n    float sdfin=1000.0;\n    float sdt1= sdTriPrism( p- vec3(0.0), vec2(1.0) );\n    float sdt2= sdTriPrism( -p.xyz- vec3(0.0), vec2(0.5,1.2) );\n    float sdt3= sdTriPrism( p.xzy- vec3(0.0), vec2(0.5,1.2) );\n    sdfin =max(sdt1, -sdt2);\n    sdfin =max(sdfin, -sdt3);\n    return sdfin;\n  }\n\n  float sdCrossRep(vec3 p) {\n          vec3 q = mod(p + 1.0, 2.0) - 1.0;\n          return sdCrossHex(q);\n  }\n\n  float sdCrossRepScale(vec3 p, float s) {\n          return sdCrossRep(p * s) / s;\n  }\n\n  float de(vec3 p) {\n    float scale = 4.0;\n    float dist=sdTriPrism( p-vec3(0.0), vec2(1.0,1.0) );\n          for (int i = 0; i < 5; i++) {\n                  dist = max(dist, -sdCrossRepScale(p, scale));\n                  scale *= 3.0;\n          }\n          return dist;\n  }",
    "ConvertedCode": "// author: russ\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat sdTriPrism( float3 p, float2 h ){\n    float3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdCrossHex( in float3 p ){\n    float sdfin=1000.0;\n    float sdt1= sdTriPrism( p- float3(0.0), float2(1.0) );\n    float sdt2= sdTriPrism( -p.xyz- float3(0.0), float2(0.5,1.2) );\n    float sdt3= sdTriPrism( p.xzy- float3(0.0), float2(0.5,1.2) );\n    sdfin =max(sdt1, -sdt2);\n    sdfin =max(sdfin, -sdt3);\n    return sdfin;\n}\nfloat sdCrossRep(float3 p) {\n          float3 q = fmod(p + 1.0, 2.0) - 1.0;\n          return sdCrossHex(q);\n}\nfloat sdCrossRepScale(float3 p, float s) {\n          return sdCrossRep(p * s) / s;\n}\n\n    float scale = 4.0;\n    float dist=sdTriPrism( p-float3(0.0), float2(1.0,1.0) );\n          for (int i = 0; i < 5; i++) {\n                  dist = max(dist, -sdCrossRepScale(p, scale));\n                  scale = mul(scale, 3.0);\n          }\n          return dist;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "russ",
    "OriginalCode": "float cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n  }\n\n  float cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n  }\n\n  float de(vec3 p){\n    float d = cylIntersection(p);\n    float s = 1.;\n    for(int i = 0;i<5;i++){\n      p *= 3.; s*=3.;\n      float d2 = cylUnion(p) / s;\n      d = max(d,-d2);\n      p = mod(p+1. , 2.) - 1.;\n    }\n    return d;\n  }",
    "ConvertedCode": "// author: russ\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat cylUnion(float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.0;\n}\nfloat cylIntersection(float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.0;\n}\n\n    float d = cylIntersection(p);\n    float s = 1.0;\n    float3 p_iter = p;\n    for(int i = 0;i<5;i++){\n      p_iter = mul(p_iter, 3.0); s=mul(s,3.0);\n      float d2 = cylUnion(p_iter) / s;\n      d = max(d,-d2);\n      p_iter = fmod(p_iter+1.0 , 2.0) - 1.0;\n    }\n    return d;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "russ",
    "OriginalCode": "float cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n  }\n\n  float cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n  }\n\n  float de(vec3 p){\n    float d = cylIntersection(p);\n    float s = 1.;\n    for(int i = 0;i<5;i++){\n      p *= 3.; s*=3.;\n      float d2 = cylUnion(p) / s;\n      d = max(d,d2);\n      p = mod(p+1. , 2.) - 1.;\n    }\n    return d;\n  }",
    "ConvertedCode": "// author: russ\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat cylUnion(float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.0;\n}\nfloat cylIntersection(float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.0;\n}\n\n    float d = cylIntersection(p);\n    float s = 1.0;\n    float3 p_iter = p;\n    for(int i = 0;i<5;i++){\n      p_iter = mul(p_iter, 3.0); s=mul(s,3.0);\n      float d2 = cylUnion(p_iter) / s;\n      d = max(d,d2);\n      p_iter = fmod(p_iter+1.0 , 2.0) - 1.0;\n    }\n    return d;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "jorge2017a1",
    "OriginalCode": "float maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n  float sdBox( vec3 p, vec3 b ){\n    vec3  di = abs(p) - b;\n    float mc = maxcomp(di);\n    return min(mc,length(max(di,0.0)));\n  }\n\n  float cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n  }\n\n  float cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n  }\n\n  float dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)\n  {\n    vec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n  }\n\n  float de(vec3 p){\n    float d = dsCapsule(vec3(-0.0,0.0,0.0), vec3(2.0,1.0,0.1), 1.0, p);\n    float s = 1.;\n    for(int i = 0;i<5;i++){\n      p *= 3.; s*=3.;\n      float d2 = cylUnion(p) / s;\n      float d3=sdBox(p, vec3(2.0,1.0,2.5));\n      d = max(d,-d2);\n      p = mod(p+1. , 2.) - 1.;\n    }\n    return d;\n  }",
    "ConvertedCode": "// author: jorge2017a1\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat maxcomp(in float3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( float3 p, float3 b ){\n    float3  di = abs(p) - b;\n    float mc = maxcomp(di);\n    return min(mc,length(max(di,0.0)));\n}\nfloat cylUnion(float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.0;\n}\nfloat cylIntersection(float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.0;\n}\nfloat dsCapsule(float3 point_a, float3 point_b, float r, float3 point_p)\n{\n    float3 ap = point_p - point_a;\n    float3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    float3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n    float d = dsCapsule(float3(-0.0,0.0,0.0), float3(2.0,1.0,0.1), 1.0, p);\n    float s = 1.0;\n    float3 p_iter = p;\n    for(int i = 0;i<5;i++){\n      p_iter = mul(p_iter, 3.0); s=mul(s,3.0);\n      float d2 = cylUnion(p_iter) / s;\n      float d3=sdBox(p_iter, float3(2.0,1.0,2.5));\n      d = max(d,-d2);\n      p_iter = fmod(p_iter+1.0 , 2.0) - 1.0;\n    }\n    return d;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "butadiene",
    "OriginalCode": "Large Sierpinski area with cube superstructure\n\n  mat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n  }\n  float cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n  }\n  float tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<12;i++){\n      if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n      if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n      if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;\n      z *= scale;\n      z.xyz += offset*(1.0-scale);\n    }\n    return (cube(z.xyz,vec3(1.5)))/z.w;\n  }\n  float de(vec3 p){\n    float s = 1.;\n    p = abs(p)-4.*s;\n    p = abs(p)-2.*s;\n    p = abs(p)-1.*s;\n    return tetcol(p,vec3(1),1.8,vec3(0.));\n  }",
    "ConvertedCode": "// author: butadiene\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\nfloat cube(float3 p,float3 s){\n    float3 q = abs(p);\n    float3 m = max(s-q,0.0);\n    return length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\nfloat tetcol(float3 p,float3 offset,float scale,float3 col){\n    float4 z = float4(p,1.0);\n    for(int i = 0;i<12;i++){\n      if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.0;\n      if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.0;\n      if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.0;\n      z = mul(z, scale);\n      z.xyz += offset*(1.0-scale);\n    }\n    return (cube(z.xyz,float3(1.5)))/z.w;\n}\n\n    float s = 1.0;\n    float3 p_iter = p;\n    p_iter = abs(p_iter)-4.0*s;\n    p_iter = abs(p_iter)-2.0*s;\n    p_iter = abs(p_iter)-1.0*s;\n    return tetcol(p_iter,float3(1),1.8,float3(0.0));",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "tholzer",
    "OriginalCode": "IcoDodecaStar\n\n  // Dodecahedron: radius = circumsphere radius\n  float sdDodecahedron(vec3 p, float radius){\n    const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a,b),c)-n.x) * radius;\n  }\n  // Icosahedron: radius = circumsphere radius\n  float sdIcosahedron(vec3 p, float radius){\n    const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);\n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a,b),c)-n1.x,d) * radius;\n  }\n  float de(vec3 p){\n    float radius = 0.5;\n    return min(sdDodecahedron(p,radius),  sdIcosahedron(p.zyx,radius));\n  }",
    "ConvertedCode": "// author: tholzer\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n// Dodecahedron: radius = circumsphere radius\nfloat sdDodecahedron(float3 p, float radius){\n    const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;\n    const float3 n = normalize(float3(phi,1,0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a,b),c)-n.x) * radius;\n}\n// Icosahedron: radius = circumsphere radius\nfloat sdIcosahedron(float3 p, float radius){\n    const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n    const float3 n1 = normalize(float3(q,1,0));\n    const float3 n2 = float3(0.57735026919);  // = sqrt(3)/3);\n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a,b),c)-n1.x,d) * radius;\n}\n\n    float radius = 0.5;\n    return min(sdDodecahedron(p,radius),  sdIcosahedron(p.zyx,radius));",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "tholzer",
    "OriginalCode": "Rack Wheel\n\n  #define opRepeat(p,c) (mod(p,c)-0.5*c)\n  #define opDifference(a,b) max(a,-b)\n\n  float length2( vec2 p ) {\n    return sqrt( p.x*p.x + p.y*p.y );\n  }\n\n  float length8( vec2 p ) {\n    p = p*p; p = p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/8.0 );\n  }\n\n  float sdCylinder (in vec3 p, in vec2 h ){\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)); }\n\n\n  float sdTorus82( vec3 p, vec2 t ){\n    vec2 q = vec2(length2(p.xz)-t.x, p.y);\n    return length8(q) - t.y;\n  }\n\n  float de( in vec3 pos){\n    return opDifference(sdTorus82(pos, vec2(0.20, 0.1)),\n      sdCylinder (opRepeat (vec3 (atan(pos.x, pos.z)/6.2831\n                                  ,pos.y\n                                  ,0.02+0.5*length(pos))\n                            ,vec3(0.05, 1.0, 0.05))\n                  ,vec2(0.02, 0.6)));\n  }",
    "ConvertedCode": "// author: tholzer\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\nfloat length2( float2 p ) {\n    return sqrt( p.x*p.x + p.y*p.y );\n}\nfloat length8( float2 p ) {\n    p = p*p; p = p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdCylinder (in float3 p, in float2 h ){\n  float2 d = abs(float2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)); \n}\n\nfloat sdTorus82( float3 p, float2 t ){\n    float2 q = float2(length2(p.xz)-t.x, p.y);\n    return length8(q) - t.y;\n}\n\n    return max(sdTorus82(p, float2(0.20, 0.1)),-sdCylinder ((fmod((float3 (atan2(p.x, p.z)/6.2831,p.y,0.02+0.5*length(p))),float3(0.05, 1.0, 0.05))-0.5*float3(0.05, 1.0, 0.05)),float2(0.02, 0.6)));",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "karang",
    "OriginalCode": "float snoise(vec2 p) {\n    vec2 f = fract(p);\n    p = floor(p);\n    float v = p.x+p.y*1000.0;\n    vec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n    r = fract(100000.0*sin(r*.001));\n    f = f*f*(3.0-2.0*f);\n    return 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n  }\n  float terrain(vec2 p, int octaves) {\n    float h = 0.0;\n    float w = 0.5;\n    float m = 0.4;\n    for (int i=0; i<12; i++) {\n      if (i==octaves) break;\n      h += w * snoise((p * m));\n      w *= 0.5;\n      m *= 2.0;\n    }\n    return h;\n  }\n  float terrainSand(vec2 p, int octaves) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<12 ; i++) {\n      if (i==octaves) break;\n      h += abs(snoise(p*f)/f);\n      f *= 2.0;\n    }\n    return h;\n  }\n  float map(vec3 p) {\n    float dMin = 28.0;\n    float d;\n    escape = -1.0;\n    int octaves = 9;\n    float h = terrain(p.xz, octaves);\n    h += smoothstep(0.0, 1.1, h);\n    h += smoothstep(-0.1, 1.0, p.y)*0.6;\n    d = p.y - h;\n    if (d<dMin) { // Mountains\n      dMin = d;\n      escape = 0.0;\n    }\n    if (h<0.5) { // Sand dunes\n      float s = 0.3 * terrainSand(p.xz*0.2, octaves);\n      d = p.y -0.35 + s;\n      if (d<dMin) {\n        dMin = d;\n        escape = 1.1;\n      }\n    }\n    return dMin;\n  }",
    "ConvertedCode": "// author: karang\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\nfloat snoise(float2 p) {\n    float2 f = frac(p);\n    p = floor(p);\n    float v = p.x+p.y*1000.0;\n    float4 r = float4(v, v+1.0, v+1000.0, v+1001.0);\n    r = frac(100000.0*sin(r*0.001));\n    f = f*f*(3.0-2.0*f);\n    return 2.0*(lerp(lerp(r.x, r.y, f.x), lerp(r.z, r.w, f.x), f.y))-1.0;\n}\nfloat terrain(float2 p, int octaves) {\n    float h = 0.0;\n    float w = 0.5;\n    float m = 0.4;\n    for (int i=0; i<12; i++) {\n      if (i==octaves) break;\n      h += w * snoise((p * m));\n      w=mul(w, 0.5);\n      m=mul(m, 2.0);\n    }\n    return h;\n}\nfloat terrainSand(float2 p, int octaves) {\n    float h = 0.0;\n    float f = 1.0;\n    for (int i=0 ; i<12 ; i++) {\n      if (i==octaves) break;\n      h += abs(snoise(p*f)/f);\n      f=mul(f, 2.0);\n    }\n    return h;\n}\n\n// This is likely intended to be the main 'de' function body\n    float dMin = 28.0;\n    float d;\n    //escape = -1.0;\n    int octaves = 9;\n    float h = terrain(p.xz, octaves);\n    h += smoothstep(0.0, 1.1, h);\n    h += smoothstep(-0.1, 1.0, p.y)*0.6;\n    d = p.y - h;\n    if (d<dMin) { // Mountains\n      dMin = d;\n      //escape = 0.0;\n    }\n    if (h<0.5) { // Sand dunes\n      float s = 0.3 * terrainSand(p.xz*0.2, octaves);\n      d = p.y -0.35 + s;\n      if (d<dMin) {\n        dMin = d;\n        //escape = 1.1;\n      }\n    }\n    return dMin;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "kamoshika",
    "OriginalCode": "float de(vec3 p){\n    vec3 Q;\n    Q=p;\n    Q.xy=vec2(atan(Q.x,Q.y)/.157,length(Q.xy)-3.);\n    Q.zx=fract(Q.zx)-.5;\n    return min(min(length(Q.xy),length(Q.yz))-.2,p.y+.5);\n  }",
    "ConvertedCode": "// author: kamoshika\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.157\n// B: 3.0\n// C: 0.5\n// Offset: N/A\n\n    float3 Q;\n    float3 p_iter = p;\n    Q=p_iter;\n    Q.xy=float2(atan2(Q.x,Q.y)/A,length(Q.xy)-B);\n    Q.zx=frac(Q.zx)-C;\n    return min(min(length(Q.xy),length(Q.yz))-0.2,p_iter.y+0.5);",
    "A": 0.157,
    "B": 3.0,
    "C": 0.5,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "XT95",
    "OriginalCode": "mat3 rotate( in vec3 v, in float angle) {\n    float c = cos(angle); float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n      (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n      (1.0 - c) * v.x * v.z - s * v.y,  (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n  }\n  float box( in vec3 p, in vec3 data ){ return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z); }\n  float arch( vec3 p ) { \n    if(p.y<40.1) p.y += 3.3;\n    vec3 a = vec3( fract(p.x/45.5-.5)-.5, -p.y+40., fract(p.z/32.9-.5)-.5 );\n    float d = -sqrt( a.y*a.y + min(a.x*a.x,a.z*a.z)*2000.)+19.5;\n    if (abs(p.x)<28.) d -= 1.;\n    d = max(d, a.y);\n    d = max(d, -a.y-24.);\n    return d*.8;\n  }\n  float column1( vec3 p ) {\n    vec3 pp = p;\n    pp.z = mod(p.z, 32.9)-32.9/2.;\n    pp.x = mod(p.x-44., 44.0)-44.0/2.;\n    float d = length(pp.xz) - 4.;\n    d = min(d, box(pp-vec3(0.,40.,0.), vec3(6.,2.,6.)));\n    d = max(d, abs(p.x)-50.);\n    d = max(d, p.y-40.);\n    d = min(d, arch(p));\n    return d;\n  }\n  float column2( vec3 p ) {\n    float yy = pow(p.y-13., .5)*1.2;\n    vec3 pp = p;\n    pp.z = mod(p.z-32.9/2., 65.8)-65.8/2.;\n    pp.x = mod(p.x-44., 44.0)-44.0/2.;\n    float d = length(pp.xz) - 3. + sin(p.y*p.y*.004+3.8)*.3;\n    pp.z = mod(p.z+32.9/2., 65.8)-65.8/2.;\n    d = min(d, max(abs(pp.x), abs(pp.z)) - 3.);\n    pp.z = mod(p.z, 32.9)-32.9/2.;\n    float y = pow(p.y-40., .5)*1.;\n    d = min(d, box(pp-vec3(0.,40.,0.), vec3(6.-y,3.,6.-y))*.8);d = min(d, box(pp-vec3(0.,12.,0.), vec3(4.5,3.,4.5))*.8);\n    d = max(d, abs(p.x)-50.);\n    d = max(d, p.y-40.);\n    d = min(d, arch(p));\n    return d;\n  }\n  float stings( in vec3 p ) {\n    vec3 pp = p;\n    pp.z = mod(p.z, 32.9)-32.9/2.;\n    vec3 ppp = pp;\n    pp = rotate(vec3(0.,0.,1.), .4*-sign(p.x)) * pp; \n    float d = length(pp.zy-vec2(0.,120.))-1.4;\n    d = max(d, -abs(ppp.x)+16.5);\n    d = min(d, length(pp.zy-vec2(0.,120.))-.3);\n    d = max(d, abs(p.x)-30.);\n    d = max(d, -abs(p.x)+3.);\n    d = max(d, abs(p.z)-60.);\n    return d;\n  }\n  float map( in vec3 p ) {\n    const vec3 dim = vec3(66.2, 77.75, 142.0);\n    const vec3 dim2 = vec3(dim.x-49., 80., dim.z-32.);\n    float d = -box(p-vec3(0.,dim.y, 0.), dim );\n    d = min(d, column1(p));  d = min(d, column2(p-vec3(0.,60.,0.)));\n    d = min(d, box(p-vec3(0., 67., 0.),vec3(dim2.x+10.,5.,dim2.z+10.)));\n    d = min(d, box(p-vec3(0., 72., 0.),vec3(dim2.x+10.4,.5,dim2.z+10.4)));\n    d = min(d, -p.y+120.);  d = max(d, -box(p-vec3(0.,186.,0.), dim2+vec3(-1.,100.,0.)));    \n    d = max(d, p.y-dim2.y-100.);\n    vec3 pp = p;    // windows on the top\n    pp.z = mod(p.z-32.9/2., 65.8)-65.8/2.;\n    d = max(d, -box(pp-vec3(0.,140.,0.), vec3(dim.x,5.,5.) ) );\n    pp.z = mod(p.z+32.9/2., 65.8)-65.8/2.;\n    d = max(d, -length(pp.zy-vec2(0.,160.))+4. );\n    d = min(d, stings(p));\n    return d;\n  }",
    "ConvertedCode": "// author: XT95\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader uses a function 'map' which may be intended as the main 'de' function.\n// The last function defined is used as the body.\n\nfloat box( in float3 p, in float3 data ){ return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z); }\nfloat arch( float3 p ) { \n    if(p.y<40.1) p.y += 3.3;\n    float3 a = float3( frac(p.x/45.5-0.5)-0.5, -p.y+40.0, frac(p.z/32.9-0.5)-0.5 );\n    float d = -sqrt( a.y*a.y + min(a.x*a.x,a.z*a.z)*2000.0)+19.5;\n    if (abs(p.x)<28.0) d -= 1.0;\n    d = max(d, a.y);\n    d = max(d, -a.y-24.0);\n    return d*0.8;\n}\nfloat column1( float3 p ) {\n    float3 pp = p;\n    pp.z = fmod(p.z, 32.9)-32.9/2.0;\n    pp.x = fmod(p.x-44.0, 44.0)-44.0/2.0;\n    float d = length(pp.xz) - 4.0;\n    d = min(d, box(pp-float3(0.0,40.0,0.0), float3(6.0,2.0,6.0)));\n    d = max(d, abs(p.x)-50.0);\n    d = max(d, p.y-40.0);\n    d = min(d, arch(p));\n    return d;\n}\nfloat column2( float3 p ) {\n    float yy = pow(p.y-13.0, 0.5)*1.2;\n    float3 pp = p;\n    pp.z = fmod(p.z-32.9/2.0, 65.8)-65.8/2.0;\n    pp.x = fmod(p.x-44.0, 44.0)-44.0/2.0;\n    float d = length(pp.xz) - 3.0 + sin(p.y*p.y*0.004+3.8)*0.3;\n    pp.z = fmod(p.z+32.9/2.0, 65.8)-65.8/2.0;\n    d = min(d, max(abs(pp.x), abs(pp.z)) - 3.0);\n    pp.z = fmod(p.z, 32.9)-32.9/2.0;\n    float y = pow(p.y-40.0, 0.5)*1.0;\n    d = min(d, box(pp-float3(0.0,40.0,0.0), float3(6.0-y,3.0,6.0-y))*0.8);d = min(d, box(pp-float3(0.0,12.0,0.0), float3(4.5,3.0,4.5))*0.8);\n    d = max(d, abs(p.x)-50.0);\n    d = max(d, p.y-40.0);\n    d = min(d, arch(p));\n    return d;\n}\nfloat stings( in float3 p ) {\n    float3 pp = p;\n    pp.z = fmod(p.z, 32.9)-32.9/2.0;\n    float3 ppp = pp;\n    pp = mul((mul(float3x3(cos(0.4*-sign(p.x)), -sin(0.4*-sign(p.x)), 0, sin(0.4*-sign(p.x)), cos(0.4*-sign(p.x)), 0, 0, 0, 1), float3(0.0,0.0,1.0))), pp); \n    float d = length(pp.zy-float2(0.0,120.0))-1.4;\n    d = max(d, -abs(ppp.x)+16.5);\n    d = min(d, length(pp.zy-float2(0.0,120.0))-0.3);\n    d = max(d, abs(p.x)-30.0);\n    d = max(d, -abs(p.x)+3.0);\n    d = max(d, abs(p.z)-60.0);\n    return d;\n}\n    const float3 dim = float3(66.2, 77.75, 142.0);\n    const float3 dim2 = float3(dim.x-49.0, 80.0, dim.z-32.0);\n    float d = -box(p-float3(0.0,dim.y, 0.0), dim );\n    d = min(d, column1(p));  d = min(d, column2(p-float3(0.0,60.0,0.0)));\n    d = min(d, box(p-float3(0.0, 67.0, 0.0),float3(dim2.x+10.0,5.0,dim2.z+10.0)));\n    d = min(d, box(p-float3(0.0, 72.0, 0.0),float3(dim2.x+10.4,0.5,dim2.z+10.4)));\n    d = min(d, -p.y+120.0);  d = max(d, -box(p-float3(0.0,186.0,0.0), dim2+float3(-1.0,100.0,0.0)));    \n    d = max(d, p.y-dim2.y-100.0);\n    float3 pp = p;    // windows on the top\n    pp.z = fmod(p.z-32.9/2.0, 65.8)-65.8/2.0;\n    d = max(d, -box(pp-float3(0.0,140.0,0.0), float3(dim.x,5.0,5.0) ) );\n    pp.z = fmod(p.z+32.9/2.0, 65.8)-65.8/2.0;\n    d = max(d, -length(pp.zy-float2(0.0,160.0))+4.0 );\n    d = min(d, stings(p));\n    return d;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  }
]