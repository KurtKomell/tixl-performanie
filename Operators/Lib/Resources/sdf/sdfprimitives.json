[
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){\n    float r = 1; // the radius\n    return length(p) - r;\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float r = A; // the radius\n    return length(p) - r;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){\n    vec3 n = vec3(0.,1.,0.);       // plane's normal vector\n    float distanceFromOrigin = 0.; // position along normal\n\n    return dot(p, n) + distanceFromOrigin;\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.0\n// B: N/A\n// C: N/A\n// Offset: (0.0,1.0,0.0)\n\n    float3 n = Offset;       // plane's normal vector\n    float distanceFromOrigin = A; // position along normal\n\n    return dot(p, n) + distanceFromOrigin;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 1.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){ // cheap version\n    vec3 size = vec3(1.); //dimensions on each axis\n    vec3 d = abs(p) - size;\n\n    return max(max(d.x, d.y), d.z);\n  }\n\n  float de(vec3 p){\n    vec3 size = vec3(1.) // dimensions on each axis\n    vec3 d = abs(p) - size;\n    float md = min(d, vec3(0));\n\n    return length(max(d, vec3(0))) + max(max(md.x, md.y), md.z);\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float3 size = float3(A); // dimensions on each axis\n    float3 d = abs(p) - size;\n    float3 md = min(d, float3(0));\n\n    return length(max(d, float3(0))) + max(max(md.x, md.y), md.z);",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){  // cheap version\n    vec2 p0 = p.xy;    // the plane the box is in (xy, yz, xz)\n    vec2 bd = vec2(1.) // the dimensions of the box\n    vec2 d = abs(p0) - bd;\n\n    return max(d.x, d.y);\n  }\n\n  float de(vec3 p){\n    vec2 p0 = p.xy;    // the plane the box is in (xy, yz, xz)\n    vec2 bd = vec2(1.) // the dimensions of the box\n    vec2 d = abs(p0) - bd;\n    vec2 md = min(d, vec2(0.));\n\n    return length(max(d, vec2(0))) + max(max(md.x, md.y), md.z);\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 p0 = p.xy;    // the plane the box is in (xy, yz, xz)\n    float2 bd = float2(A); // the dimensions of the box\n    float2 d = abs(p0) - bd;\n    float2 md = min(d, float2(0.0));\n\n    return length(max(d, float2(0))) + max(max(md.x, md.y), md.z);",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){ \n    vec2 p0 = p.xy; // the plane the section lies in\n    vec2 md = min(p, vec2(0));\n\n    return length(max(p0, vec2(0))) + max(max(md.x, md.y), md.z);\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 p0 = p.xy; // the plane the section lies in\n    float2 md = min(p.xy, float2(0));\n\n    return length(max(p0, float2(0))) + max(max(md.x, md.y), p.z);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "tholzer",
    "OriginalCode": "float de(vec3 p){\n    float s = 0.2; // size of the cross members\n    float da = max (abs(p.x), abs(p.y));\n    float db = max (abs(p.y), abs(p.z));\n    float dc = max (abs(p.z), abs(p.x));\n    return min(da,min(db,dc)) - s;\n  }",
    "ConvertedCode": "// author: tholzer\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.2\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float s = A; // size of the cross members\n    float da = max (abs(p.x), abs(p.y));\n    float db = max (abs(p.y), abs(p.z));\n    float dc = max (abs(p.z), abs(p.x));\n    return min(da,min(db,dc)) - s;",
    "A": 0.2,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p) {\n    p = abs(p);\n    if (p.x < max(p.y, p.z)) p = p.yzx;\n    if (p.x < max(p.y, p.z)) p = p.yzx;\n    float b = max(max(max(\n      dot(p, normalize(vec3(1, 1, 1))),\n      dot(p.xz, normalize(vec2(PHI+1, 1)))),\n      dot(p.yx, normalize(vec2(1, PHI)))),\n      dot(p.xz, normalize(vec2(1, PHI))));\n    float l = length(p);\n    return l - 1.5 - 0.2 * (1.5 / 2)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.5\n// B: 0.2\n// C: 1.5\n// Offset: N/A\n\n    float3 p_iter = abs(p);\n    if (p_iter.x < max(p_iter.y, p_iter.z)) p_iter = p_iter.yzx;\n    if (p_iter.x < max(p_iter.y, p_iter.z)) p_iter = p_iter.yzx;\n    float b = max(max(max(\n      dot(p_iter, normalize(float3(1, 1, 1))),\n      dot(p_iter.xz, normalize(float2(2.618034+1, 1)))),\n      dot(p_iter.yx, normalize(float2(1, 2.618034)))),\n      dot(p_iter.xz, normalize(float2(1, 2.618034))));\n    float l = length(p_iter);\n    return l - A - B * (C / 2)* cos(min(sqrt(1.01 - b / l)*(3.14159265 / 0.25), 3.14159265));",
    "A": 1.5,
    "B": 0.2,
    "C": 1.5,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){\n    float radius = 1.;\n    return length(p.xz)-radius; // xy, yz for other directions\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float radius = A;\n    return length(p.xz)-radius; // xy, yz for other directions",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){\n    float r = 1.;\n    float height = 1.;\n\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - height);\n\n    return d;\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float r = A;\n    float height = B;\n\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - height);\n\n    return d;",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de( vec3 p){\n    float ra = 0.5;  // radius of cylinder\n    float rb = 0.1;  // radius of rounding\n    float h  = 0.4;  // height of cylinder\n\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.5\n// B: 0.1\n// C: 0.4\n// Offset: N/A\n\n    float ra = A;  // radius of cylinder\n    float rb = B;  // radius of rounding\n    float h  = C;  // height of cylinder\n\n    float2 d = float2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;",
    "A": 0.5,
    "B": 0.1,
    "C": 0.4,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){\n    float r = 1.; // radius\n    float c = 1.; // length\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n  }\n\nAlternate method\n\n  float de_line_segment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = clamp(dot(p - a, ab) / dot(ab, ab), 0., 1.);\n\n    return length((ab*t + a) - p);\n  }\n\n  float de(vec3 p){\n    vec3 a = vec3(0., -1., 0.); // location of top\n    vec3 b = vec3(0.,  1., 0.); // location of bottom\n    float r = 1.; // radius\n\n    return de_line_segment(p, a, b) - r;\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\nfloat de_line_segment(float3 p, float3 a, float3 b) {\n    float3 ab = b - a;\n    float t = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n\n    return length((ab*t + a) - p);\n}\n\n    float3 a = float3(0.0, -1.0, 0.0); // location of top\n    float3 b = float3(0.0,  1.0, 0.0); // location of bottom\n    float r = 1.0; // radius\n\n    return de_line_segment(p, a, b) - r;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){\n    float smallRadius = 1.; // minor radius\n    float largeRadius = 2.; // major radius\n\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n  }\n\nAlternate method using circular line SDF - subtract minor radius from result\n\n  float de(vec3 p){\n    float r = 1.; // major radius\n    float l = length(p.xz) - r;\n\n    return length(vec2(p.y, l));\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n    float r = A; // major radius\n    float l = length(p.xz) - r;\n\n    return length(float2(p.y, l));",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){ \n    float r = 1.; // radius of the circle\n    float l = length(p.xz) - r;\n\n    return length(vec2(p.y, l));\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float r = A; // radius of the circle\n    float l = length(p.xz) - r;\n\n    return length(float2(p.y, l));",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){\n    float width = 1.;\n    float height = 1.;\n\n    return max(q.y - height, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - width);\n  }\n\nIncircle Variant\n\n  float de(vec3 p){\n    float width = 1.;\n    float height = 1.;\n    vec3 q = abs(p);\n\n    return max(q.y - height, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - (width*sqrt(3)*0.5));\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n    float width = A;\n    float height = B;\n    float3 q = abs(p);\n\n    return max(q.y - height, max(q.x*sqrt(3)*0.5 + q.z*0.5, q.z) - (width*sqrt(3)*0.5));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Cupe / Mercury",
    "OriginalCode": "float de(vec3 p){\n    float radius = 1.;\n    float height = 3.;\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 tip = q - vec2(0, height);\n    vec2 mantleDir = normalize(vec2(height, radius));\n    float mantle = dot(tip, mantleDir);\n    float d = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n    // distance to tip\n    if ((q.y > height) && (projected < 0)) {\n      d = max(d, length(tip));\n    }\n\n    // distance to base ring\n    if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n      d = max(d, length(q - vec2(radius, 0)));\n    }\n    return d;\n  }",
    "ConvertedCode": "// author: Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 3.0\n// C: N/A\n// Offset: N/A\n\n    float radius = A;\n    float height = B;\n    float2 q = float2(length(p.xz), p.y);\n    float2 tip = q - float2(0, height);\n    float2 mantleDir = normalize(float2(height, radius));\n    float mantle = dot(tip, mantleDir);\n    float d = max(mantle, -q.y);\n    float projected = dot(tip, float2(mantleDir.y, -mantleDir.x));\n\n    // distance to tip\n    if ((q.y > height) && (projected < 0)) {\n      d = max(d, length(tip));\n    }\n\n    // distance to base ring\n    if ((q.x > radius) && (projected > length(float2(height, radius)))) {\n      d = max(d, length(q - float2(radius, 0)));\n    }\n    return d;",
    "A": 1.0,
    "B": 3.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "Akleman and Chen via Cupe / Mercury",
    "OriginalCode": "const vec3 GDFVectors[19] = vec3[](\n    normalize(vec3(1, 0, 0)),\n    normalize(vec3(0, 1, 0)),\n    normalize(vec3(0, 0, 1)),\n\n    normalize(vec3(1, 1, 1 )),\n    normalize(vec3(-1, 1, 1)),\n    normalize(vec3(1, -1, 1)),\n    normalize(vec3(1, 1, -1)),\n\n    normalize(vec3(0, 1, PHI+1)),\n    normalize(vec3(0, -1, PHI+1)),\n    normalize(vec3(PHI+1, 0, 1)),\n    normalize(vec3(-PHI-1, 0, 1)),\n    normalize(vec3(1, PHI+1, 0)),\n    normalize(vec3(-1, PHI+1, 0)),\n\n    normalize(vec3(0, PHI, 1)),\n    normalize(vec3(0, -PHI, 1)),\n    normalize(vec3(1, 0, PHI)),\n    normalize(vec3(-1, 0, PHI)),\n    normalize(vec3(PHI, 1, 0)),\n    normalize(vec3(-PHI, 1, 0))\n  );\n\n  // Version with variable exponent.\n  // This is slow and does not produce correct distances, but allows for bulging of objects.\n  float fGDF(vec3 p, float r, float e, int begin, int end) {\n          float d = 0;\n          for (int i = begin; i <= end; ++i)\n                  d += pow(abs(dot(p, GDFVectors[i])), e);\n          return pow(d, 1/e) - r;\n  }\n\n  // Version with without exponent, creates objects with sharp edges and flat faces\n  float fGDF(vec3 p, float r, int begin, int end) {\n          float d = 0;\n          for (int i = begin; i <= end; ++i)\n                  d = max(d, abs(dot(p, GDFVectors[i])));\n          return d - r;\n  }",
    "ConvertedCode": "// author: Akleman and Chen via Cupe / Mercury\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This does not contain a 'de' function and is likely a library of helpers.\n// It cannot be run as a standalone shader snippet.",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "",
    "OriginalCode": "float de(vec3 p){\n    float r = 1.; // radius\n\n    return fGDF(p, r, 3, 6);\n  }\n\nWith Exponent\n\n  float de(vec3 p){\n    float r = 1.; // radius\n    float e = 1.; // exponent\n\n    return fGDF(p, r, e, 3, 6);\n  }",
    "ConvertedCode": "// author: \n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions and calls an undefined function 'fGDF'.\n// It cannot be fully converted without the definition of 'fGDF'. Using the last 'de' function found.\n\n    float r = 1.0; // radius\n    float e = 1.0; // exponent\n\n    // return fGDF(p, r, e, 3, 6);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "",
    "OriginalCode": "float de(vec3 p){\n    float r = 1.; // radius\n\n    return fGDF(p, r, 13, 18);\n  }\n\nWith Exponent\n\n  float de(vec3 p){\n    float r = 1.; // radius\n    float e = 1.; // exponent\n\n    return fGDF(p, r, e, 13, 18);\n  }",
    "ConvertedCode": "// author: \n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions and calls an undefined function 'fGDF'.\n// It cannot be fully converted without the definition of 'fGDF'. Using the last 'de' function found.\n\n    float r = 1.0; // radius\n    float e = 1.0; // exponent\n\n    // return fGDF(p, r, e, 13, 18);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "",
    "OriginalCode": "float de(vec3 p){\n    float r = 1.; // radius\n\n    return fGDF(p, r, 3, 12);\n  }\n\nWith Exponent\n\n  float de(vec3 p){\n    float r = 1.; // radius\n    float e = 1.; // exponent\n\n    return fGDF(p, r, e, 3, 12);\n  }",
    "ConvertedCode": "// author: \n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions and calls an undefined function 'fGDF'.\n// It cannot be fully converted without the definition of 'fGDF'. Using the last 'de' function found.\n\n    float r = 1.0; // radius\n    float e = 1.0; // exponent\n\n    // return fGDF(p, r, e, 3, 12);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "",
    "OriginalCode": "float de(vec3 p){\n    float r = 1.; // radius\n\n    return fGDF(p, r, 0, 6);\n  }\n\nWith Exponent\n\n  float de(vec3 p){\n    float r = 1.; // radius\n    float e = 1.; // exponent\n\n    return fGDF(p, r, e, 0, 6);\n  }",
    "ConvertedCode": "// author: \n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions and calls an undefined function 'fGDF'.\n// It cannot be fully converted without the definition of 'fGDF'. Using the last 'de' function found.\n\n    float r = 1.0; // radius\n    float e = 1.0; // exponent\n\n    // return fGDF(p, r, e, 0, 6);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "",
    "OriginalCode": "float de(vec3 p){\n    float r = 1.; // radius\n\n    return fGDF(p, r, 3, 18);\n  }\n\nWith Exponent\n\n  float de(vec3 p){\n    float r = 1.; // radius\n    float e = 1.; // exponent\n\n    return fGDF(p, r, e, 3, 18);\n  }",
    "ConvertedCode": "// author: \n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions and calls an undefined function 'fGDF'.\n// It cannot be fully converted without the definition of 'fGDF'. Using the last 'de' function found.\n\n    float r = 1.0; // radius\n    float e = 1.0; // exponent\n\n    // return fGDF(p, r, e, 3, 18);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float s = 1.; // size\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n  }\n\nApproximate (cheaper)\n\n  float de( vec3 p){\n    float s = 1.;\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n    float s = A;\n    float3 p_iter = abs(p);\n    return (p_iter.x+p_iter.y+p_iter.z-s)*0.57735027;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "tholzer",
    "OriginalCode": "float de(vec3 p){\n    float radius = 1.;\n    const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);\n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a,b),c)-n1.x,d) * radius;\n  }",
    "ConvertedCode": "// author: tholzer\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float radius = A;\n    const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n    const float3 n1 = normalize(float3(q,1,0));\n    const float3 n2 = float3(0.57735026919);  // = sqrt(3)/3);\n\n    float3 p_iter = abs(p / radius);\n    float a = dot(p_iter, n1.xyz);\n    float b = dot(p_iter, n1.zxy);\n    float c = dot(p_iter, n1.yzx);\n    float d = dot(p_iter, n2) - n1.x;\n    return max(max(max(a,b),c)-n1.x,d) * radius;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "tholzer",
    "OriginalCode": "float de(vec3 p){\n    float radius = 1.;\n    const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;\n    const vec3 n = normalize(vec3(phi,1,0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a,b),c)-n.x) * radius;\n  }",
    "ConvertedCode": "// author: tholzer\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float radius = A;\n    const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;\n    const float3 n = normalize(float3(phi,1,0));\n\n    float3 p_iter = abs(p / radius);\n    float a = dot(p_iter, n.xyz);\n    float b = dot(p_iter, n.zxy);\n    float c = dot(p_iter, n.yzx);\n    return (max(max(a,b),c)-n.x) * radius;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "yx",
    "OriginalCode": "// Rhombic Dodecahedron\nfloat de( vec3 p ){ \n  p = abs( p );\n  p += p.yzx;\n  return ( max( max( p.x, p.y ), p.z ) - 1.0 ) * sqrt( 0.5 );\n}",
    "ConvertedCode": "// author: yx\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n// Rhombic Dodecahedron\n\n  float3 p_iter = abs( p );\n  p_iter += p_iter.yzx;\n  return ( max( max( p_iter.x, p_iter.y ), p_iter.z ) - A ) * sqrt( 0.5 );",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "TLC123",
    "OriginalCode": "float sdOctahedron( in vec3 p, in float s)// by Iq 2019{\n      p = abs(p);\n      float m = p.x+p.y+p.z-s;\n      vec3 q;\n           if( 3.0*p.x < m ) q = p.xyz;\n      else if( 3.0*p.y < m ) q = p.yzx;\n      else if( 3.0*p.z < m ) q = p.zxy;\n      else return m*0.57735027;\n\n      float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n      return length(vec3(q.x,q.y-s+k,q.z-k));\n  }\n\n  float de(vec3 op){ \n    vec3 b = vec3(1,2,3); // size\n    float ch = 0.25;      // chamfer amount\n    float r = 0.05;       // rounding\n\n    vec3 p = abs(op)+vec3(ch)+vec3(r);\n    p = max(vec3(0),p-b);\n    float d =fOctahedron(p,ch);\n    return d-r ;\n  }",
    "ConvertedCode": "// author: TLC123\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader calls an undefined function 'fOctahedron'.\n// It cannot be fully converted without its definition.\nfloat sdOctahedron( in float3 p, in float s)// by Iq 2019{\n      p = abs(p);\n      float m = p.x+p.y+p.z-s;\n      float3 q;\n           if( 3.0*p.x < m ) q = p.xyz;\n      else if( 3.0*p.y < m ) q = p.yzx;\n      else if( 3.0*p.z < m ) q = p.zxy;\n      else return m*0.57735027;\n\n      float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n      return length(float3(q.x,q.y-s+k,q.z-k));\n}\n\n    float3 p_iter = p;\n    float3 b = float3(1,2,3); // size\n    float ch = 0.25;      // chamfer amount\n    float r = 0.05;       // rounding\n\n    p_iter = abs(p_iter)+float3(ch)+float3(r);\n    p_iter = max(float3(0),p_iter-b);\n    // float d =fOctahedron(p_iter,ch);\n    return 0.0; //d-r ;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "FabriceNeyret2",
    "OriginalCode": "float de(vec3 p) {\n    float scale = 7.;\n    float thickness = 0.05;\n    float bias = 0.1;\n\n    p *= scale;\n    return (abs(dot(sin(p*.5), cos(p.zxy * 1.23)) - bias) / scale - thickness)*0.55;\n  }",
    "ConvertedCode": "// author: FabriceNeyret2\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 7.0\n// B: 0.05\n// C: 0.1\n// Offset: N/A\n\n    float scale = A;\n    float thickness = B;\n    float bias = C;\n    float3 p_iter = p;\n\n    p_iter = mul(p_iter, scale);\n    return (abs(dot(sin(p_iter*0.5), cos(p_iter.zxy * 1.23)) - bias) / scale - thickness)*0.55;",
    "A": 7.0,
    "B": 0.05,
    "C": 0.1,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "dr2",
    "OriginalCode": "float de(vec3 p){\n    float rt = 15.;\n    float rg = 4.;\n    float ws = 0.3;\n\n    p.xz = vec2 (rt * atan (p.z, - p.x), length (p.xz) - rt);\n    p.yz = vec2 (rg * atan (p.z, - p.y), length (p.yz) - rg);\n    return .6* max(abs(dot(sin(p), cos(p).yzx)) - ws, abs(p.z) - .5*PI);\n  }",
    "ConvertedCode": "// author: dr2\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 15.0\n// B: 4.0\n// C: 0.3\n// Offset: N/A\n\n    float rt = A;\n    float rg = B;\n    float ws = C;\n    float3 p_iter = p;\n\n    p_iter.xz = float2 (rt * atan2 (p_iter.z, - p_iter.x), length (p_iter.xz) - rt);\n    p_iter.yz = float2 (rg * atan2 (p_iter.z, - p_iter.y), length (p_iter.yz) - rg);\n    return 0.6* max(abs(dot(sin(p_iter), cos(p_iter).yzx)) - ws, abs(p_iter.z) - 0.5*3.14159265);",
    "A": 15.0,
    "B": 4.0,
    "C": 0.3,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p) {\n    vec3 r = vec3(0.2, 0.25, 0.05); // the radii on each axis\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: (0.2,0.25,0.05)\n\n    float3 r = Offset; // the radii on each axis\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.2,
    "OffsetY": 0.25,
    "OffsetZ": 0.05
  },
  {
    "Author": "iq",
    "OriginalCode": "float de( vec3 p){\n    float e = 0.05;          // edge thickness\n    vec3 b = vec3(.3,.5,.4); // box dimensions\n    p = abs(p)-b;\n    vec3 q = abs(p+e)-e;\n\n    return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.05\n// B: N/A\n// C: N/A\n// Offset: (0.3,0.5,0.4)\n\n    float e = A;          // edge thickness\n    float3 b = Offset; // box dimensions\n    float3 p_iter = abs(p)-b;\n    float3 q = abs(p_iter+e)-e;\n\n    return min(min(\n      length(max(float3(p_iter.x,q.y,q.z),0.0))+min(max(p_iter.x,max(q.y,q.z)),0.0),\n      length(max(float3(q.x,p_iter.y,q.z),0.0))+min(max(q.x,max(p_iter.y,q.z)),0.0)),\n      length(max(float3(q.x,q.y,p_iter.z),0.0))+min(max(q.x,max(q.y,p_iter.z)),0.0));",
    "A": 0.05,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.3,
    "OffsetY": 0.5,
    "OffsetZ": 0.4
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){   // located at origin\n      float h = 1.;   // height\n      float r1 = 0.5; // radius at bottom\n      float r2 = 0.2; // radius at top\n\n      vec2 q = vec2( length(p.xz), p.y );\n\n      vec2 k1 = vec2(r2,h);\n      vec2 k2 = vec2(r2-r1,2.0*h);\n      vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n      vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n      float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n      return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a = float3(0,0,0); \n      float3 b = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){\n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){\n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n\n    float3 p_iter = abs(p);\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a = float3(0,0,0); \n      float3 b = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a = float3(0,0,0); \n      float3 b = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a = float3(0,0,0); \n      float3 b = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 1.; // desired cone angle\n    float ra = 1.; // radius of the sphere from which it is cut\n\n    vec2 c = vec2(sin(angle),cos(angle));\n    vec2 p0 = vec2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: 1.0\n// C: N/A\n// Offset: N/A\n\n    float angle = A; // desired cone angle\n    float ra = B; // radius of the sphere from which it is cut\n\n    float2 c = float2(sin(angle),cos(angle));\n    float2 p0 = float2( length(p.xz), p.y );\n    float l = length(p0) - ra;\n    float m = length(p0 - c*clamp(dot(p0,c),0.0,ra) );\n    return max(l,m*sign(c.y*p0.x-c.x*p0.y));",
    "A": 1.0,
    "B": 1.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float angle = 2.0; // angle spanned\n    float ra = 0.25;   // major radius\n    float rb = 0.05;   // minor radius\n\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 2.0\n// B: 0.25\n// C: 0.05\n// Offset: N/A\n\n    float angle = A; // angle spanned\n    float ra = B;   // major radius\n    float rb = C;   // minor radius\n    float3 p_iter = p;\n\n    float2 sc = float2(sin(angle), cos(angle));\n    p_iter.x = abs(p_iter.x);\n    float k = (sc.y*p_iter.x>sc.x*p_iter.y) ? dot(p_iter.xy,sc) : length(p_iter.xy);\n    return sqrt( dot(p_iter,p_iter) + ra*ra - 2.0*ra*k ) - rb;",
    "A": 2.0,
    "B": 0.25,
    "C": 0.05,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.; // height\n    float m2 = h*h + 0.25;\n\n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 1.0\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float h = A; // height\n    float m2 = h*h + 0.25;\n    float3 p_iter = p;\n\n    // symmetry\n    p_iter.xz = abs(p_iter.xz);\n    p_iter.xz = (p_iter.z>p_iter.x) ? p_iter.zx : p_iter.xz;\n    p_iter.xz -= 0.5;\n\n    // project into face plane (2D)\n    float3 q = float3( p_iter.z, h*p_iter.y - 0.5*p_iter.x, h*p_iter.x + 0.5*p_iter.y);\n\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p_iter.z)/(m2+0.25), 0.0, 1.0 );\n\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n\n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p_iter.y));;",
    "A": 1.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    vec2 h = vec2(0.5, 0.2); // height, thickness\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n    float2 h = float2(0.5, 0.2); // height, thickness\n    float3 p_iter = p;\n    const float k = sqrt(3.0);\n    h.x=mul(h.x, 0.5*k);\n    p_iter.xy /= h.x;\n    p_iter.x = abs(p_iter.x) - 1.0;\n    p_iter.y = p_iter.y + 1.0/k;\n    if( p_iter.x+k*p_iter.y>0.0 ) p_iter.xy=float2(p_iter.x-k*p_iter.y,-k*p_iter.x-p_iter.y)/2.0;\n    p_iter.x -= clamp( p_iter.x, -2.0, 0.0 );\n    float d1 = length(p_iter.xy)*sign(-p_iter.y)*h.x;\n    float d2 = abs(p_iter.z)-h.y;\n    return length(max(float2(d1,d2),0.0)) + min(max(d1,d2), 0.0);",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float la = 0.15;  // first axis\n    float lb = 0.25;  // second axis\n    float h  = 0.04;  // thickness\n    float ra = 0.08;  // corner radius\n\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    vec2 bb = b-2.0*p.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: 0.15\n// B: 0.25\n// C: 0.04\n// Offset: N/A\n\n    float la = A;  // first axis\n    float lb = B;  // second axis\n    float h  = C;  // thickness\n    float ra = 0.08;  // corner radius\n    float3 p_iter = abs(p);\n\n    float2 b = float2(la,lb);\n    float2 bb = b-2.0*p_iter.xz;\n\n    float f = clamp((b.x*bb.x-b.y*bb.y)/dot(b,b), -1.0, 1.0 );\n    float2 q = float2(length(p_iter.xz-0.5*b*float2(1.0-f,1.0+f))*sign(p_iter.x*b.y+p_iter.z*b.x-b.x*b.y)-ra, p_iter.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));",
    "A": 0.15,
    "B": 0.25,
    "C": 0.04,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  },
  {
    "Author": "iq",
    "OriginalCode": "float de(vec3 p){ \n    float h = 1.;   // height\n    float r1 = 0.5; // radius at bottom\n    float r2 = 0.2; // radius at top\n\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n  }\n\n\n  float de(vec3 p){   // between two points a and b\n      vec3 a = vec3(0,0,0); \n      vec3 b = vec3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      vec3  ba = b - a;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      vec3 pa = p - a;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      vec3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n  }",
    "ConvertedCode": "// author: iq\n// Converted from GLSL to HLSL.\n// Default parameter values from original code:\n// A: N/A\n// B: N/A\n// C: N/A\n// Offset: N/A\n\n// NOTE: This shader has multiple 'de' functions. Using the last one.\n\n      float3 a_point = float3(0,0,0); \n      float3 b_point = float3(0,1,0); // point b\n      float r1 = 1.0; // radius at b\n      float r2 = 0.1; // radius at a\n\n      float3  ba = b_point - a_point;\n      float l2 = dot(ba,ba);\n      float rr = r1 - r2;\n      float a2 = l2 - rr*rr;\n      float il2 = 1.0/l2;\n\n      float3 pa = p - a_point;\n      float y = dot(pa,ba);\n      float z = y - l2;\n      float3 d2 =  pa*l2 - ba*y;\n      float x2 = dot(d2, d2);\n      float y2 = y*y*l2;\n      float z2 = z*z*l2;\n\n      float k = sign(rr)*rr*rr*x2;\n      if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n      if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;",
    "A": 0.0,
    "B": 0.0,
    "C": 0.0,
    "OffsetX": 0.0,
    "OffsetY": 0.0,
    "OffsetZ": 0.0
  }
]